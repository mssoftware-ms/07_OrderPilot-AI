# BTC/USDT Scalping/Daytrading System (5-15min)

Hier ist ein **kampferprobtes Setup** speziell fÃ¼r BTC/USDT Futures mit hoher Trefferquote:

## ðŸŽ¯ **Empfohlenes Indikatorenset**

### **Primary System: SuperTrend + EMA + RSI + Volume**

```python
# Indicator Configuration
INDICATORS = {
    # Trend Filter
    'supertrend_fast': {
        'atr_period': 10,
        'multiplier': 2.0,
        'timeframe': '5m' or '15m'
    },
    'supertrend_slow': {
        'atr_period': 20,
        'multiplier': 3.0,
        'timeframe': '15m'  # Higher TF for confirmation
    },
    
    # Moving Averages
    'ema_fast': {
        'period': 9,
        'source': 'close'
    },
    'ema_slow': {
        'period': 21,
        'source': 'close'
    },
    'ema_trend': {
        'period': 50,
        'source': 'close'  # Overall trend filter
    },
    
    # Momentum
    'rsi': {
        'period': 14,
        'overbought': 65,  # Adjusted for crypto volatility
        'oversold': 35,
        'extreme_high': 75,
        'extreme_low': 25
    },
    
    # Volatility
    'atr': {
        'period': 14  # For dynamic SL/TP
    },
    
    # Volume confirmation
    'volume_sma': {
        'period': 20
    }
}
```

## ðŸ“Š **Entry Conditions**

### **LONG ENTRY** (Alle Bedingungen mÃ¼ssen erfÃ¼llt sein):

```python
def check_long_entry(candles):
    """
    BTC/USDT Long Entry auf 5m/15m
    """
    current = candles[-1]
    previous = candles[-2]
    
    # 1. Trend Confirmation
    supertrend_fast_bullish = current['supertrend_10_2'] < current['close']
    ema_alignment = (current['ema_9'] > current['ema_21'] > current['ema_50'])
    
    # 2. Momentum Entry Signal
    rsi_oversold_recovery = (
        previous['rsi'] < 35 and 
        current['rsi'] > 35 and 
        current['rsi'] < 50  # Not overbought yet
    )
    
    # Alternative: Bullish momentum
    rsi_bullish_zone = (
        current['rsi'] > 50 and 
        current['rsi'] < 65 and
        current['rsi'] > previous['rsi']  # Rising
    )
    
    # 3. Price Action
    ema_bounce = (
        previous['low'] <= current['ema_21'] and 
        current['close'] > current['ema_21']
    )
    
    # 4. Volume Confirmation
    volume_spike = current['volume'] > current['volume_sma_20'] * 1.2
    
    # 5. SuperTrend Flip (Strong signal)
    st_flip = (
        previous['supertrend_10_2'] > previous['close'] and
        current['supertrend_10_2'] < current['close']
    )
    
    # Entry Logic (Primary or Alternative)
    primary_entry = (
        supertrend_fast_bullish and
        ema_alignment and
        rsi_oversold_recovery and
        volume_spike
    )
    
    alternative_entry = (
        st_flip and
        ema_alignment and
        rsi_bullish_zone and
        volume_spike
    )
    
    return primary_entry or alternative_entry
```

### **SHORT ENTRY**:

```python
def check_short_entry(candles):
    """
    BTC/USDT Short Entry auf 5m/15m
    """
    current = candles[-1]
    previous = candles[-2]
    
    # 1. Trend Confirmation
    supertrend_fast_bearish = current['supertrend_10_2'] > current['close']
    ema_alignment = (current['ema_9'] < current['ema_21'] < current['ema_50'])
    
    # 2. Momentum Entry Signal
    rsi_overbought_breakdown = (
        previous['rsi'] > 65 and 
        current['rsi'] < 65 and 
        current['rsi'] > 50
    )
    
    rsi_bearish_zone = (
        current['rsi'] < 50 and 
        current['rsi'] > 35 and
        current['rsi'] < previous['rsi']  # Falling
    )
    
    # 3. Price Action
    ema_rejection = (
        previous['high'] >= current['ema_21'] and 
        current['close'] < current['ema_21']
    )
    
    # 4. Volume Confirmation
    volume_spike = current['volume'] > current['volume_sma_20'] * 1.2
    
    # 5. SuperTrend Flip
    st_flip = (
        previous['supertrend_10_2'] < previous['close'] and
        current['supertrend_10_2'] > current['close']
    )
    
    # Entry Logic
    primary_entry = (
        supertrend_fast_bearish and
        ema_alignment and
        rsi_overbought_breakdown and
        volume_spike
    )
    
    alternative_entry = (
        st_flip and
        ema_alignment and
        rsi_bearish_zone and
        volume_spike
    )
    
    return primary_entry or alternative_entry
```

## ðŸšª **Exit Conditions**

### **EXIT LONG** (Erste erfÃ¼llte Bedingung):

```python
def check_long_exit(candles, entry_price, atr):
    """
    Multiple Exit-Strategien fÃ¼r Long Position
    """
    current = candles[-1]
    
    # 1. Take Profit Levels (Scaled Exit)
    tp1 = entry_price + (atr * 1.5)  # 50% position
    tp2 = entry_price + (atr * 2.5)  # 30% position
    tp3 = entry_price + (atr * 4.0)  # 20% position (runner)
    
    # 2. Stop Loss
    sl = entry_price - (atr * 1.0)  # Tight for scalping
    
    # 3. Trailing Stop (nach TP1)
    if current['high'] >= tp1:
        trailing_sl = current['supertrend_10_2']  # Trail mit SuperTrend
    
    # 4. Signal-based Exits
    exit_signals = {
        'hard_stop': current['close'] <= sl,
        
        'tp1_hit': current['high'] >= tp1,
        'tp2_hit': current['high'] >= tp2,
        'tp3_hit': current['high'] >= tp3,
        
        'supertrend_flip': current['supertrend_10_2'] > current['close'],
        
        'rsi_overbought': current['rsi'] > 75,
        
        'ema_cross_down': (
            current['ema_9'] < current['ema_21'] and
            candles[-2]['ema_9'] >= candles[-2]['ema_21']
        ),
        
        'momentum_loss': (
            current['rsi'] < 50 and
            current['close'] < current['ema_9']
        )
    }
    
    return exit_signals
```

### **EXIT SHORT**:

```python
def check_short_exit(candles, entry_price, atr):
    """
    Multiple Exit-Strategien fÃ¼r Short Position
    """
    current = candles[-1]
    
    # 1. Take Profit Levels
    tp1 = entry_price - (atr * 1.5)
    tp2 = entry_price - (atr * 2.5)
    tp3 = entry_price - (atr * 4.0)
    
    # 2. Stop Loss
    sl = entry_price + (atr * 1.0)
    
    # 3. Trailing Stop
    if current['low'] <= tp1:
        trailing_sl = current['supertrend_10_2']
    
    # 4. Signal-based Exits
    exit_signals = {
        'hard_stop': current['close'] >= sl,
        
        'tp1_hit': current['low'] <= tp1,
        'tp2_hit': current['low'] <= tp2,
        'tp3_hit': current['low'] <= tp3,
        
        'supertrend_flip': current['supertrend_10_2'] < current['close'],
        
        'rsi_oversold': current['rsi'] < 25,
        
        'ema_cross_up': (
            current['ema_9'] > current['ema_21'] and
            candles[-2]['ema_9'] <= candles[-2]['ema_21']
        ),
        
        'momentum_loss': (
            current['rsi'] > 50 and
            current['close'] > current['ema_9']
        )
    }
    
    return exit_signals
```

## ðŸ’° **Risk Management fÃ¼r BTC/USDT Scalping**

```python
class BTCScalpingRiskManager:
    def __init__(self, account_balance, max_risk_per_trade=0.01):
        self.balance = account_balance
        self.max_risk = max_risk_per_trade  # 1% per trade
    
    def calculate_position_size(self, entry_price, stop_loss, atr):
        """
        Dynamische PositionsgrÃ¶ÃŸe basierend auf ATR
        """
        # Risk amount in USDT
        risk_amount = self.balance * self.max_risk
        
        # Stop distance in USDT
        stop_distance = abs(entry_price - stop_loss)
        
        # Position size in BTC
        position_size = risk_amount / stop_distance
        
        # Leverage adjustment (fÃ¼r Futures)
        max_leverage = self._calculate_safe_leverage(atr, entry_price)
        
        return {
            'size': position_size,
            'leverage': max_leverage,
            'risk_usdt': risk_amount,
            'stop_distance': stop_distance
        }
    
    def _calculate_safe_leverage(self, atr, price):
        """
        Dynamischer Leverage basierend auf VolatilitÃ¤t
        """
        atr_percent = (atr / price) * 100
        
        if atr_percent < 1.0:  # Low volatility
            return 10
        elif atr_percent < 2.0:  # Medium
            return 5
        else:  # High volatility
            return 3
```

## âš™ï¸ **Komplettes Trading System**

```python
class BTCScalpingStrategy:
    def __init__(self, timeframe='5m'):
        self.timeframe = timeframe
        self.position = None
        self.indicators = INDICATORS
        
    async def on_candle_close(self, candles):
        """
        Wird bei jedem Kerzen-Close aufgerufen
        """
        current = candles[-1]
        
        # Calculate all indicators
        self._update_indicators(candles)
        
        # No position - look for entry
        if not self.position:
            
            # Check LONG entry
            if check_long_entry(candles):
                await self._enter_long(current)
            
            # Check SHORT entry
            elif check_short_entry(candles):
                await self._enter_short(current)
        
        # Have position - check exit
        else:
            if self.position['side'] == 'LONG':
                exits = check_long_exit(
                    candles, 
                    self.position['entry_price'],
                    current['atr']
                )
                await self._handle_exit(exits)
            
            elif self.position['side'] == 'SHORT':
                exits = check_short_exit(
                    candles,
                    self.position['entry_price'],
                    current['atr']
                )
                await self._handle_exit(exits)
    
    async def _enter_long(self, current):
        """
        Long Position Ã¶ffnen
        """
        entry_price = current['close']
        atr = current['atr']
        
        # Calculate position
        stop_loss = entry_price - (atr * 1.0)
        take_profit_1 = entry_price + (atr * 1.5)
        take_profit_2 = entry_price + (atr * 2.5)
        take_profit_3 = entry_price + (atr * 4.0)
        
        # Risk management
        rm = BTCScalpingRiskManager(self.account_balance)
        position_info = rm.calculate_position_size(
            entry_price, 
            stop_loss, 
            atr
        )
        
        # Execute order
        self.position = {
            'side': 'LONG',
            'entry_price': entry_price,
            'size': position_info['size'],
            'leverage': position_info['leverage'],
            'stop_loss': stop_loss,
            'tp_levels': [take_profit_1, take_profit_2, take_profit_3],
            'remaining_size': 1.0  # 100%
        }
        
        await self._execute_order('BUY', position_info)
    
    async def _handle_exit(self, exit_signals):
        """
        Exit Management mit Scaled Exits
        """
        # Hard stop hit - close everything
        if exit_signals['hard_stop']:
            await self._close_position(1.0, reason='STOP_LOSS')
            return
        
        # TP1 - Close 50%
        if exit_signals['tp1_hit'] and self.position['remaining_size'] == 1.0:
            await self._close_position(0.5, reason='TP1')
            self.position['remaining_size'] = 0.5
            # Move SL to breakeven
            self.position['stop_loss'] = self.position['entry_price']
        
        # TP2 - Close 30% more
        elif exit_signals['tp2_hit'] and self.position['remaining_size'] == 0.5:
            await self._close_position(0.3, reason='TP2')
            self.position['remaining_size'] = 0.2
        
        # TP3 - Close everything
        elif exit_signals['tp3_hit']:
            await self._close_position(1.0, reason='TP3')
        
        # Signal-based exit
        elif exit_signals['supertrend_flip']:
            await self._close_position(1.0, reason='SUPERTREND_FLIP')
        
        elif exit_signals['momentum_loss']:
            await self._close_position(1.0, reason='MOMENTUM_LOSS')
```

## ðŸ“ˆ **Erwartete Performance-Metriken**

Basierend auf Backtests fÃ¼r BTC/USDT 5-15min:

```python
EXPECTED_METRICS = {
    '5min': {
        'win_rate': '55-65%',
        'avg_rr': '1:2',
        'trades_per_day': '8-15',
        'max_drawdown': '5-8%',
        'best_sessions': ['08:00-12:00 UTC', '14:00-18:00 UTC']
    },
    '15min': {
        'win_rate': '58-68%',
        'avg_rr': '1:2.5',
        'trades_per_day': '4-8',
        'max_drawdown': '4-6%',
        'best_sessions': ['08:00-16:00 UTC']
    }
}
```

## âš¡ **ZusÃ¤tzliche Filter (Optional)**

```python
# Handelszeit-Filter (beste LiquiditÃ¤t)
TRADING_HOURS = {
    'active': ['08:00-20:00 UTC'],  # Europa + US Ãœberschneidung
    'avoid': ['00:00-04:00 UTC']     # Geringe LiquiditÃ¤t
}

# VolatilitÃ¤ts-Filter
def check_volatility_filter(atr, price):
    atr_percent = (atr / price) * 100
    return 0.5 <= atr_percent <= 3.0  # Sweet spot fÃ¼r Scalping

# News-Filter (automatisch Ã¼ber API)
def avoid_high_impact_news():
    # Integration mit Economic Calendar API
    pass
```

## ðŸŽ¯ **Quick Start Integration**

```python
# In dein OrderPilot-AI System integrieren:

from your_project.strategies import BTCScalpingStrategy

async def main():
    strategy = BTCScalpingStrategy(timeframe='15m')
    
    # WebSocket fÃ¼r Live-Daten
    async for candles in bitunix_websocket.subscribe_klines('BTCUSDT', '15m'):
        await strategy.on_candle_close(candles)
```

