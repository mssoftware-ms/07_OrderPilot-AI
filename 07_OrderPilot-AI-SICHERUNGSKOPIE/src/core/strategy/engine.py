"""Strategy Engine for Rule-Based Trading.

Implements various trading strategies using technical indicators,
with AI-powered signal validation and risk management.

REFACTORED: Individual strategy implementations moved to strategies/ package.
"""

import logging
from abc import ABC, abstractmethod
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any

import pandas as pd

from src.common.event_bus import Event, EventType, event_bus
from src.core.broker import OrderRequest
from src.core.indicators.engine import IndicatorConfig, IndicatorEngine, IndicatorType
from src.database.models import OrderSide, OrderType, TimeInForce

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class StrategyType(Enum):
    """Types of trading strategies."""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    BREAKOUT = "breakout"
    PAIRS_TRADING = "pairs_trading"
    ARBITRAGE = "arbitrage"
    SCALPING = "scalping"
    SWING = "swing"
    CUSTOM = "custom"


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    strategy_name: str
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    timestamp: datetime
    price: Decimal
    quantity: int | None = None
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None
    reason: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy."""
    name: str
    strategy_type: StrategyType
    symbols: list[str]
    parameters: dict[str, Any]
    risk_params: dict[str, Any]
    indicators: list[IndicatorConfig]
    enabled: bool = True
    max_positions: int = 5
    position_sizing: str = "fixed"  # fixed, kelly, risk_parity
    ai_validation: bool = True


@dataclass
class StrategyState:
    """Current state of a strategy."""
    positions: dict[str, int] = field(default_factory=dict)
    pending_orders: set[str] = field(default_factory=set)
    last_signal: Signal | None = None
    last_update: datetime | None = None
    performance: dict[str, float] = field(default_factory=dict)
    is_active: bool = True


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, config: StrategyConfig, indicator_engine: IndicatorEngine):
        """Initialize strategy.

        Args:
            config: Strategy configuration
            indicator_engine: Indicator calculation engine
        """
        self.config = config
        self.indicator_engine = indicator_engine
        self.state = StrategyState()
        self.signal_history: deque[Signal] = deque(maxlen=100)

    @abstractmethod
    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate strategy and generate signal.

        Args:
            data: Market data (OHLCV)

        Returns:
            Trading signal or None
        """
        pass

    def update_position(self, symbol: str, quantity: int) -> None:
        """Update position tracking.

        Args:
            symbol: Trading symbol
            quantity: Position quantity (negative for short)
        """
        if quantity == 0:
            self.state.positions.pop(symbol, None)
        else:
            self.state.positions[symbol] = quantity

    def get_position(self, symbol: str) -> int:
        """Get current position.

        Args:
            symbol: Trading symbol

        Returns:
            Position quantity (0 if no position)
        """
        return self.state.positions.get(symbol, 0)

    def has_position(self, symbol: str) -> bool:
        """Check if strategy has position.

        Args:
            symbol: Trading symbol

        Returns:
            True if has position
        """
        return symbol in self.state.positions

    def calculate_position_size(
        self,
        symbol: str,
        signal_confidence: float,
        account_equity: Decimal,
        current_price: Decimal
    ) -> int:
        """Calculate position size.

        Args:
            symbol: Trading symbol
            signal_confidence: Signal confidence (0-1)
            account_equity: Total account equity
            current_price: Current price

        Returns:
            Position size in shares
        """
        if self.config.position_sizing == "fixed":
            # Fixed percentage of equity
            allocation_pct = self.config.risk_params.get('allocation_pct', 0.1)
            position_value = account_equity * Decimal(str(allocation_pct))
            shares = int(position_value / current_price)

        elif self.config.position_sizing == "kelly":
            # Kelly Criterion
            win_prob = signal_confidence
            win_loss_ratio = self.config.risk_params.get('win_loss_ratio', 1.5)
            kelly_f = (win_prob * win_loss_ratio - (1 - win_prob)) / win_loss_ratio

            # Apply Kelly fraction with safety factor
            safety_factor = self.config.risk_params.get('kelly_safety', 0.25)
            allocation = min(kelly_f * safety_factor, 0.25)  # Max 25% allocation

            position_value = account_equity * Decimal(str(max(allocation, 0)))
            shares = int(position_value / current_price)

        elif self.config.position_sizing == "risk_parity":
            # Risk parity sizing based on volatility
            volatility = self.config.risk_params.get('volatility', 0.02)
            target_risk = self.config.risk_params.get('target_risk', 0.01)

            if volatility > 0:
                allocation = target_risk / volatility
                position_value = account_equity * Decimal(str(min(allocation, 0.2)))
                shares = int(position_value / current_price)
            else:
                shares = 0
        else:
            # Default to fixed small size
            shares = 100

        # Apply maximum position limit
        max_shares = self.config.risk_params.get('max_shares', 1000)
        return min(shares, max_shares)


class StrategyEngine:
    """Engine for managing multiple trading strategies."""

    def __init__(self):
        """Initialize strategy engine."""
        self.indicator_engine = IndicatorEngine()
        self.strategies: dict[str, BaseStrategy] = {}
        self.active_strategies: set[str] = set()

        # Import strategy classes from strategies package
        from .strategies import (
            TrendFollowingStrategy,
            MeanReversionStrategy,
            MomentumStrategy,
            BreakoutStrategy,
            ScalpingStrategy,
        )

        # Strategy factory
        self.strategy_classes = {
            StrategyType.TREND_FOLLOWING: TrendFollowingStrategy,
            StrategyType.MEAN_REVERSION: MeanReversionStrategy,
            StrategyType.MOMENTUM: MomentumStrategy,
            StrategyType.BREAKOUT: BreakoutStrategy,
            StrategyType.SCALPING: ScalpingStrategy
        }

        logger.info("Strategy engine initialized")

    def create_strategy(self, config: StrategyConfig) -> BaseStrategy:
        """Create a strategy instance.

        Args:
            config: Strategy configuration

        Returns:
            Strategy instance
        """
        strategy_class = self.strategy_classes.get(config.strategy_type)

        if not strategy_class:
            raise ValueError(f"Unknown strategy type: {config.strategy_type}")

        strategy = strategy_class(config, self.indicator_engine)

        # Register strategy
        self.strategies[config.name] = strategy

        if config.enabled:
            self.active_strategies.add(config.name)

        logger.info(f"Created strategy: {config.name} ({config.strategy_type.value})")

        return strategy

    def enable_strategy(self, name: str) -> None:
        """Enable a strategy.

        Args:
            name: Strategy name
        """
        if name in self.strategies:
            self.active_strategies.add(name)
            self.strategies[name].state.is_active = True
            logger.info(f"Enabled strategy: {name}")

    def disable_strategy(self, name: str) -> None:
        """Disable a strategy.

        Args:
            name: Strategy name
        """
        if name in self.active_strategies:
            self.active_strategies.discard(name)
            self.strategies[name].state.is_active = False
            logger.info(f"Disabled strategy: {name}")

    async def evaluate_all(
        self,
        market_data: dict[str, pd.DataFrame]
    ) -> list[Signal]:
        """Evaluate all active strategies.

        Args:
            market_data: Market data by symbol

        Returns:
            List of generated signals
        """
        signals = []

        for strategy_name in self.active_strategies:
            strategy = self.strategies[strategy_name]

            # Get data for strategy symbols
            for symbol in strategy.config.symbols:
                if symbol in market_data:
                    try:
                        signal = await strategy.evaluate(market_data[symbol])

                        if signal:
                            signals.append(signal)

                    except Exception as e:
                        logger.error(f"Error evaluating {strategy_name}: {e}")

        # Sort by confidence
        signals.sort(key=lambda s: s.confidence, reverse=True)

        return signals

    def combine_signals(self, signals: list[Signal]) -> Signal | None:
        """Combine multiple signals into consensus (refactored).

        Args:
            signals: List of signals

        Returns:
            Combined signal or None
        """
        # Guard: empty signals
        if not signals:
            return None

        # Group signals by symbol
        symbol_signals = self._group_signals_by_symbol(signals)

        # Vote on each symbol
        combined_signals = []
        for symbol, sig_list in symbol_signals.items():
            consensus_signal = self._create_consensus_for_symbol(symbol, sig_list)
            if consensus_signal:
                combined_signals.append(consensus_signal)

        # Return highest confidence combined signal
        if combined_signals:
            return max(combined_signals, key=lambda s: s.confidence)

        return None

    def _group_signals_by_symbol(self, signals: list[Signal]) -> dict[str, list[Signal]]:
        """Group signals by symbol.

        Args:
            signals: List of signals

        Returns:
            Dictionary mapping symbol to list of signals
        """
        symbol_signals: dict[str, list[Signal]] = {}
        for signal in signals:
            if signal.symbol not in symbol_signals:
                symbol_signals[signal.symbol] = []
            symbol_signals[signal.symbol].append(signal)
        return symbol_signals

    def _create_consensus_for_symbol(
        self,
        symbol: str,
        sig_list: list[Signal]
    ) -> Signal | None:
        """Create consensus signal for a single symbol.

        Args:
            symbol: Trading symbol
            sig_list: List of signals for this symbol

        Returns:
            Consensus signal or None if no consensus
        """
        # Count signal types
        buy_count, close_count = self._count_signal_types(sig_list)
        avg_confidence = self._calculate_avg_confidence(sig_list)
        total = len(sig_list)

        # Determine consensus
        if buy_count > total / 2:
            return self._create_buy_consensus_signal(symbol, sig_list, buy_count, avg_confidence)
        elif close_count > total / 2:
            return self._create_close_consensus_signal(symbol, sig_list, close_count, avg_confidence)

        return None

    def _count_signal_types(self, sig_list: list[Signal]) -> tuple[int, int]:
        """Count buy and close signals.

        Args:
            sig_list: List of signals

        Returns:
            Tuple of (buy_count, close_count)
        """
        buy_count = sum(1 for s in sig_list if s.signal_type == SignalType.BUY)
        close_count = sum(1 for s in sig_list if s.signal_type in
                         [SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT])
        return buy_count, close_count

    def _calculate_avg_confidence(self, sig_list: list[Signal]) -> float:
        """Calculate average confidence from signal list.

        Args:
            sig_list: List of signals

        Returns:
            Average confidence value
        """
        return sum(s.confidence for s in sig_list) / len(sig_list)

    def _create_buy_consensus_signal(
        self,
        symbol: str,
        sig_list: list[Signal],
        buy_count: int,
        avg_confidence: float
    ) -> Signal:
        """Create consensus BUY signal.

        Args:
            symbol: Trading symbol
            sig_list: List of signals
            buy_count: Number of buy signals
            avg_confidence: Average confidence

        Returns:
            Consensus buy signal
        """
        # Find best buy signal
        best_signal = max(
            (s for s in sig_list if s.signal_type == SignalType.BUY),
            key=lambda s: s.confidence
        )

        return Signal(
            strategy_name="consensus",
            symbol=symbol,
            signal_type=SignalType.BUY,
            confidence=avg_confidence,
            timestamp=datetime.utcnow(),
            price=best_signal.price,
            stop_loss=best_signal.stop_loss,
            take_profit=best_signal.take_profit,
            reason=f"Consensus buy ({buy_count}/{len(sig_list)} strategies)",
            metadata={'strategies': [s.strategy_name for s in sig_list]}
        )

    def _create_close_consensus_signal(
        self,
        symbol: str,
        sig_list: list[Signal],
        close_count: int,
        avg_confidence: float
    ) -> Signal:
        """Create consensus CLOSE signal.

        Args:
            symbol: Trading symbol
            sig_list: List of signals
            close_count: Number of close signals
            avg_confidence: Average confidence

        Returns:
            Consensus close signal
        """
        best_signal = sig_list[0]

        return Signal(
            strategy_name="consensus",
            symbol=symbol,
            signal_type=SignalType.CLOSE_LONG,
            confidence=avg_confidence,
            timestamp=datetime.utcnow(),
            price=best_signal.price,
            reason=f"Consensus close ({close_count}/{len(sig_list)} strategies)",
            metadata={'strategies': [s.strategy_name for s in sig_list]}
        )

    def get_strategy_stats(self, name: str) -> dict[str, Any]:
        """Get strategy statistics.

        Args:
            name: Strategy name

        Returns:
            Strategy statistics
        """
        if name not in self.strategies:
            return {}

        strategy = self.strategies[name]
        signal_history = list(strategy.signal_history)

        return {
            'name': name,
            'type': strategy.config.strategy_type.value,
            'active': strategy.state.is_active,
            'positions': strategy.state.positions,
            'total_signals': len(signal_history),
            'last_signal': strategy.state.last_signal.signal_type.value
                          if strategy.state.last_signal else None,
            'last_update': strategy.state.last_update.isoformat()
                          if strategy.state.last_update else None
        }

    def signal_to_order(self, signal: Signal) -> OrderRequest:
        """Convert signal to order request.

        Args:
            signal: Trading signal

        Returns:
            Order request
        """
        # Determine order type
        if signal.stop_loss and signal.take_profit:
            order_type = OrderType.LIMIT
            limit_price = signal.price
        else:
            order_type = OrderType.MARKET
            limit_price = None

        # Map signal to order side
        if signal.signal_type in [SignalType.BUY]:
            side = OrderSide.BUY
        elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
            side = OrderSide.SELL
        else:
            raise ValueError(f"Cannot convert signal type: {signal.signal_type}")

        return OrderRequest(
            symbol=signal.symbol,
            side=side,
            order_type=order_type,
            quantity=signal.quantity or 100,  # Default quantity
            limit_price=limit_price,
            stop_price=signal.stop_loss,
            time_in_force=TimeInForce.DAY,
            strategy_name=signal.strategy_name,
            signal_confidence=signal.confidence,
            notes=signal.reason
        )
