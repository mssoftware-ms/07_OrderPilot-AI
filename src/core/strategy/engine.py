"""Strategy Engine for Rule-Based Trading.

Implements various trading strategies using technical indicators,
with AI-powered signal validation and risk management.
"""

import logging
from abc import ABC, abstractmethod
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any

import pandas as pd

from src.common.event_bus import Event, EventType, event_bus
from src.core.broker import OrderRequest
from src.core.indicators.engine import IndicatorConfig, IndicatorEngine, IndicatorType
from src.database.models import OrderSide, OrderType, TimeInForce

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class StrategyType(Enum):
    """Types of trading strategies."""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    BREAKOUT = "breakout"
    PAIRS_TRADING = "pairs_trading"
    ARBITRAGE = "arbitrage"
    SCALPING = "scalping"
    SWING = "swing"
    CUSTOM = "custom"


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    strategy_name: str
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    timestamp: datetime
    price: Decimal
    quantity: int | None = None
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None
    reason: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy."""
    name: str
    strategy_type: StrategyType
    symbols: list[str]
    parameters: dict[str, Any]
    risk_params: dict[str, Any]
    indicators: list[IndicatorConfig]
    enabled: bool = True
    max_positions: int = 5
    position_sizing: str = "fixed"  # fixed, kelly, risk_parity
    ai_validation: bool = True


@dataclass
class StrategyState:
    """Current state of a strategy."""
    positions: dict[str, int] = field(default_factory=dict)
    pending_orders: set[str] = field(default_factory=set)
    last_signal: Signal | None = None
    last_update: datetime | None = None
    performance: dict[str, float] = field(default_factory=dict)
    is_active: bool = True


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, config: StrategyConfig, indicator_engine: IndicatorEngine):
        """Initialize strategy.

        Args:
            config: Strategy configuration
            indicator_engine: Indicator calculation engine
        """
        self.config = config
        self.indicator_engine = indicator_engine
        self.state = StrategyState()
        self.signal_history: deque[Signal] = deque(maxlen=100)

    @abstractmethod
    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate strategy and generate signal.

        Args:
            data: Market data (OHLCV)

        Returns:
            Trading signal or None
        """
        pass

    def update_position(self, symbol: str, quantity: int) -> None:
        """Update position tracking.

        Args:
            symbol: Trading symbol
            quantity: Position quantity (negative for short)
        """
        if quantity == 0:
            self.state.positions.pop(symbol, None)
        else:
            self.state.positions[symbol] = quantity

    def get_position(self, symbol: str) -> int:
        """Get current position.

        Args:
            symbol: Trading symbol

        Returns:
            Position quantity (0 if no position)
        """
        return self.state.positions.get(symbol, 0)

    def has_position(self, symbol: str) -> bool:
        """Check if strategy has position.

        Args:
            symbol: Trading symbol

        Returns:
            True if has position
        """
        return symbol in self.state.positions

    def calculate_position_size(
        self,
        symbol: str,
        signal_confidence: float,
        account_equity: Decimal,
        current_price: Decimal
    ) -> int:
        """Calculate position size.

        Args:
            symbol: Trading symbol
            signal_confidence: Signal confidence (0-1)
            account_equity: Total account equity
            current_price: Current price

        Returns:
            Position size in shares
        """
        if self.config.position_sizing == "fixed":
            # Fixed percentage of equity
            allocation_pct = self.config.risk_params.get('allocation_pct', 0.1)
            position_value = account_equity * Decimal(str(allocation_pct))
            shares = int(position_value / current_price)

        elif self.config.position_sizing == "kelly":
            # Kelly Criterion
            win_prob = signal_confidence
            win_loss_ratio = self.config.risk_params.get('win_loss_ratio', 1.5)
            kelly_f = (win_prob * win_loss_ratio - (1 - win_prob)) / win_loss_ratio

            # Apply Kelly fraction with safety factor
            safety_factor = self.config.risk_params.get('kelly_safety', 0.25)
            allocation = min(kelly_f * safety_factor, 0.25)  # Max 25% allocation

            position_value = account_equity * Decimal(str(max(allocation, 0)))
            shares = int(position_value / current_price)

        elif self.config.position_sizing == "risk_parity":
            # Risk parity sizing based on volatility
            volatility = self.config.risk_params.get('volatility', 0.02)
            target_risk = self.config.risk_params.get('target_risk', 0.01)

            if volatility > 0:
                allocation = target_risk / volatility
                position_value = account_equity * Decimal(str(min(allocation, 0.2)))
                shares = int(position_value / current_price)
            else:
                shares = 0
        else:
            # Default to fixed small size
            shares = 100

        # Apply maximum position limit
        max_shares = self.config.risk_params.get('max_shares', 1000)
        return min(shares, max_shares)


class TrendFollowingStrategy(BaseStrategy):
    """Trend following strategy using moving averages."""

    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate trend following strategy."""
        if len(data) < 200:  # Need enough data for indicators
            return None

        symbol = self.config.symbols[0]  # Single symbol for now

        # Calculate indicators
        configs = [
            IndicatorConfig(
                indicator_type=IndicatorType.SMA,
                params={'period': 50}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.SMA,
                params={'period': 200}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.RSI,
                params={'period': 14}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.MACD,
                params={'fast': 12, 'slow': 26, 'signal': 9}
            )
        ]

        results = self.indicator_engine.calculate_multiple(data, configs)

        # Get indicator values
        sma_50 = results[IndicatorType.SMA].values.iloc[-1]
        sma_200 = results[IndicatorType.SMA].values.iloc[-1]
        rsi = results[IndicatorType.RSI].values.iloc[-1]
        macd_hist = results[IndicatorType.MACD].values['histogram'].iloc[-1]

        current_price = Decimal(str(data['close'].iloc[-1]))
        has_position = self.has_position(symbol)

        # Generate signals based on rules
        signal = None

        # Golden Cross - Bullish signal
        if (sma_50 > sma_200 and
            data['close'].iloc[-1] > sma_50 and
            rsi < 70 and
            macd_hist > 0):

            if not has_position:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.7,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    stop_loss=current_price * Decimal('0.95'),
                    take_profit=current_price * Decimal('1.10'),
                    reason="Golden cross with positive MACD",
                    metadata={
                        'sma_50': float(sma_50),
                        'sma_200': float(sma_200),
                        'rsi': float(rsi),
                        'macd_hist': float(macd_hist)
                    }
                )

        # Death Cross - Bearish signal
        elif (sma_50 < sma_200 and
              data['close'].iloc[-1] < sma_50 and
              rsi > 30 and
              macd_hist < 0):

            if has_position:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.7,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    reason="Death cross with negative MACD",
                    metadata={
                        'sma_50': float(sma_50),
                        'sma_200': float(sma_200),
                        'rsi': float(rsi),
                        'macd_hist': float(macd_hist)
                    }
                )

        # Store signal
        if signal:
            self.state.last_signal = signal
            self.state.last_update = datetime.utcnow()
            self.signal_history.append(signal)

            # Emit event
            event_bus.emit(Event(
                type=EventType.STRATEGY_SIGNAL,
                timestamp=datetime.utcnow(),
                data={
                    'strategy': self.config.name,
                    'signal': signal.signal_type.value,
                    'symbol': signal.symbol,
                    'confidence': signal.confidence
                }
            ))

        return signal


class MeanReversionStrategy(BaseStrategy):
    """Mean reversion strategy using Bollinger Bands."""

    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate mean reversion strategy."""
        if len(data) < 50:
            return None

        symbol = self.config.symbols[0]

        # Calculate indicators
        configs = [
            IndicatorConfig(
                indicator_type=IndicatorType.BB,
                params={'period': 20, 'std_dev': 2}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.RSI,
                params={'period': 14}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.STD,
                params={'period': 20}
            )
        ]

        results = self.indicator_engine.calculate_multiple(data, configs)

        # Get indicator values
        bb = results[IndicatorType.BB].values
        upper_band = bb['upper'].iloc[-1]
        lower_band = bb['lower'].iloc[-1]
        middle_band = bb['middle'].iloc[-1]
        bb_percent = bb['percent'].iloc[-1]

        rsi = results[IndicatorType.RSI].values.iloc[-1]
        volatility = results[IndicatorType.STD].values.iloc[-1]

        current_price = Decimal(str(data['close'].iloc[-1]))
        has_position = self.has_position(symbol)

        signal = None

        # Oversold condition - Buy signal
        if (current_price <= Decimal(str(lower_band)) and
            rsi < 30 and
            bb_percent < 0.1):

            if not has_position:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.65,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    stop_loss=current_price * Decimal('0.97'),
                    take_profit=Decimal(str(middle_band)),
                    reason="Price at lower BB with oversold RSI",
                    metadata={
                        'bb_upper': float(upper_band),
                        'bb_lower': float(lower_band),
                        'bb_percent': float(bb_percent),
                        'rsi': float(rsi),
                        'volatility': float(volatility)
                    }
                )

        # Overbought condition - Sell signal
        elif (current_price >= Decimal(str(upper_band)) and
              rsi > 70 and
              bb_percent > 0.9):

            if has_position and self.get_position(symbol) > 0:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.65,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    reason="Price at upper BB with overbought RSI",
                    metadata={
                        'bb_upper': float(upper_band),
                        'bb_lower': float(lower_band),
                        'bb_percent': float(bb_percent),
                        'rsi': float(rsi)
                    }
                )

        # Mean reversion - Close position
        elif has_position and abs(float(current_price) - middle_band) < volatility * 0.5:
            signal = Signal(
                strategy_name=self.config.name,
                symbol=symbol,
                signal_type=SignalType.CLOSE_LONG,
                confidence=0.5,
                timestamp=datetime.utcnow(),
                price=current_price,
                reason="Price reverted to mean",
                metadata={'bb_middle': float(middle_band)}
            )

        if signal:
            self.state.last_signal = signal
            self.state.last_update = datetime.utcnow()
            self.signal_history.append(signal)

        return signal


class MomentumStrategy(BaseStrategy):
    """Momentum strategy using rate of change and volume."""

    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate momentum strategy."""
        if len(data) < 50:
            return None

        symbol = self.config.symbols[0]

        # Calculate indicators
        configs = [
            IndicatorConfig(
                indicator_type=IndicatorType.ROC,
                params={'period': 10}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.MOM,
                params={'period': 10}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.OBV,
                params={}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.RSI,
                params={'period': 14}
            )
        ]

        results = self.indicator_engine.calculate_multiple(data, configs)

        # Get indicator values
        roc = results[IndicatorType.ROC].values.iloc[-1]
        momentum = results[IndicatorType.MOM].values.iloc[-1]
        obv = results[IndicatorType.OBV].values
        obv_change = (obv.iloc[-1] - obv.iloc[-5]) / obv.iloc[-5] * 100
        rsi = results[IndicatorType.RSI].values.iloc[-1]

        current_price = Decimal(str(data['close'].iloc[-1]))
        has_position = self.has_position(symbol)

        signal = None

        # Strong momentum up
        if (roc > 5 and
            momentum > 0 and
            obv_change > 5 and
            rsi > 50 and rsi < 80):

            if not has_position:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.6,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    stop_loss=current_price * Decimal('0.96'),
                    take_profit=current_price * Decimal('1.08'),
                    reason="Strong positive momentum with volume",
                    metadata={
                        'roc': float(roc),
                        'momentum': float(momentum),
                        'obv_change': float(obv_change),
                        'rsi': float(rsi)
                    }
                )

        # Momentum exhaustion
        elif has_position and (roc < -3 or rsi > 85 or obv_change < -5):
            signal = Signal(
                strategy_name=self.config.name,
                symbol=symbol,
                signal_type=SignalType.CLOSE_LONG,
                confidence=0.6,
                timestamp=datetime.utcnow(),
                price=current_price,
                reason="Momentum exhaustion",
                metadata={
                    'roc': float(roc),
                    'obv_change': float(obv_change),
                    'rsi': float(rsi)
                }
            )

        if signal:
            self.state.last_signal = signal
            self.state.last_update = datetime.utcnow()
            self.signal_history.append(signal)

        return signal


class BreakoutStrategy(BaseStrategy):
    """Breakout strategy using support/resistance and volume."""

    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate breakout strategy."""
        if len(data) < 100:
            return None

        symbol = self.config.symbols[0]

        # Calculate indicators
        configs = [
            IndicatorConfig(
                indicator_type=IndicatorType.SUPPORT_RESISTANCE,
                params={'window': 20, 'num_levels': 3}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.ATR,
                params={'period': 14}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.ADX,
                params={'period': 14}
            )
        ]

        results = self.indicator_engine.calculate_multiple(data, configs)

        # Get indicator values
        sr = results[IndicatorType.SUPPORT_RESISTANCE].values
        resistance_levels = sr['resistance']
        support_levels = sr['support']
        atr = results[IndicatorType.ATR].values.iloc[-1]
        adx = results[IndicatorType.ADX].values.iloc[-1]

        current_price = float(data['close'].iloc[-1])
        prev_close = float(data['close'].iloc[-2])
        current_volume = data['volume'].iloc[-1]
        avg_volume = data['volume'].iloc[-20:].mean()

        has_position = self.has_position(symbol)
        signal = None

        # Resistance breakout
        if resistance_levels and current_price > resistance_levels[0]:
            price_change = (current_price - prev_close) / prev_close
            volume_ratio = current_volume / avg_volume

            if (price_change > 0.01 and
                volume_ratio > 1.5 and
                adx > 25 and
                not has_position):

                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.65,
                    timestamp=datetime.utcnow(),
                    price=Decimal(str(current_price)),
                    stop_loss=Decimal(str(resistance_levels[0] - atr)),
                    take_profit=Decimal(str(current_price + 2 * atr)),
                    reason="Resistance breakout with volume",
                    metadata={
                        'resistance': resistance_levels[0],
                        'volume_ratio': float(volume_ratio),
                        'adx': float(adx),
                        'atr': float(atr)
                    }
                )

        # Support breakdown (for closing longs)
        elif support_levels and current_price < support_levels[0]:
            if has_position:
                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.7,
                    timestamp=datetime.utcnow(),
                    price=Decimal(str(current_price)),
                    reason="Support breakdown",
                    metadata={'support': support_levels[0]}
                )

        if signal:
            self.state.last_signal = signal
            self.state.last_update = datetime.utcnow()
            self.signal_history.append(signal)

        return signal


class ScalpingStrategy(BaseStrategy):
    """High-frequency scalping strategy."""

    async def evaluate(self, data: pd.DataFrame) -> Signal | None:
        """Evaluate scalping strategy."""
        if len(data) < 20:
            return None

        symbol = self.config.symbols[0]

        # Calculate fast indicators
        configs = [
            IndicatorConfig(
                indicator_type=IndicatorType.EMA,
                params={'period': 5}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.EMA,
                params={'period': 9}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.VWAP,
                params={}
            ),
            IndicatorConfig(
                indicator_type=IndicatorType.STOCH,
                params={'k_period': 5, 'd_period': 3}
            )
        ]

        results = self.indicator_engine.calculate_multiple(data, configs)

        # Get indicator values
        ema_5 = results[IndicatorType.EMA].values.iloc[-1]
        ema_9 = results[IndicatorType.EMA].values.iloc[-1]
        vwap = results[IndicatorType.VWAP].values.iloc[-1]
        stoch = results[IndicatorType.STOCH].values
        stoch_k = stoch['k'].iloc[-1]

        current_price = Decimal(str(data['close'].iloc[-1]))
        spread = (data['high'].iloc[-1] - data['low'].iloc[-1]) / data['close'].iloc[-1]

        has_position = self.has_position(symbol)
        signal = None

        # Quick buy signal
        if (ema_5 > ema_9 and
            current_price > Decimal(str(vwap)) and
            stoch_k < 80 and
            spread < 0.005 and  # Tight spread for scalping
            not has_position):

            signal = Signal(
                strategy_name=self.config.name,
                symbol=symbol,
                signal_type=SignalType.BUY,
                confidence=0.5,
                timestamp=datetime.utcnow(),
                price=current_price,
                stop_loss=current_price * Decimal('0.995'),  # Tight stop
                take_profit=current_price * Decimal('1.005'),  # Quick profit
                reason="Scalp buy signal",
                metadata={
                    'ema_5': float(ema_5),
                    'vwap': float(vwap),
                    'stoch_k': float(stoch_k),
                    'spread': float(spread)
                }
            )

        # Quick exit
        elif has_position:
            position_time = (datetime.utcnow() -
                           self.state.last_signal.timestamp).total_seconds()

            if (position_time > 60 or  # Exit after 1 minute
                ema_5 < ema_9 or
                current_price < Decimal(str(vwap))):

                signal = Signal(
                    strategy_name=self.config.name,
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.5,
                    timestamp=datetime.utcnow(),
                    price=current_price,
                    reason="Scalp exit",
                    metadata={'position_time': position_time}
                )

        if signal:
            self.state.last_signal = signal
            self.state.last_update = datetime.utcnow()
            self.signal_history.append(signal)

        return signal


class StrategyEngine:
    """Engine for managing multiple trading strategies."""

    def __init__(self):
        """Initialize strategy engine."""
        self.indicator_engine = IndicatorEngine()
        self.strategies: dict[str, BaseStrategy] = {}
        self.active_strategies: set[str] = set()

        # Strategy factory
        self.strategy_classes = {
            StrategyType.TREND_FOLLOWING: TrendFollowingStrategy,
            StrategyType.MEAN_REVERSION: MeanReversionStrategy,
            StrategyType.MOMENTUM: MomentumStrategy,
            StrategyType.BREAKOUT: BreakoutStrategy,
            StrategyType.SCALPING: ScalpingStrategy
        }

        logger.info("Strategy engine initialized")

    def create_strategy(self, config: StrategyConfig) -> BaseStrategy:
        """Create a strategy instance.

        Args:
            config: Strategy configuration

        Returns:
            Strategy instance
        """
        strategy_class = self.strategy_classes.get(config.strategy_type)

        if not strategy_class:
            raise ValueError(f"Unknown strategy type: {config.strategy_type}")

        strategy = strategy_class(config, self.indicator_engine)

        # Register strategy
        self.strategies[config.name] = strategy

        if config.enabled:
            self.active_strategies.add(config.name)

        logger.info(f"Created strategy: {config.name} ({config.strategy_type.value})")

        return strategy

    def enable_strategy(self, name: str) -> None:
        """Enable a strategy.

        Args:
            name: Strategy name
        """
        if name in self.strategies:
            self.active_strategies.add(name)
            self.strategies[name].state.is_active = True
            logger.info(f"Enabled strategy: {name}")

    def disable_strategy(self, name: str) -> None:
        """Disable a strategy.

        Args:
            name: Strategy name
        """
        if name in self.active_strategies:
            self.active_strategies.discard(name)
            self.strategies[name].state.is_active = False
            logger.info(f"Disabled strategy: {name}")

    async def evaluate_all(
        self,
        market_data: dict[str, pd.DataFrame]
    ) -> list[Signal]:
        """Evaluate all active strategies.

        Args:
            market_data: Market data by symbol

        Returns:
            List of generated signals
        """
        signals = []

        for strategy_name in self.active_strategies:
            strategy = self.strategies[strategy_name]

            # Get data for strategy symbols
            for symbol in strategy.config.symbols:
                if symbol in market_data:
                    try:
                        signal = await strategy.evaluate(market_data[symbol])

                        if signal:
                            signals.append(signal)

                    except Exception as e:
                        logger.error(f"Error evaluating {strategy_name}: {e}")

        # Sort by confidence
        signals.sort(key=lambda s: s.confidence, reverse=True)

        return signals

    def combine_signals(self, signals: list[Signal]) -> Signal | None:
        """Combine multiple signals into consensus.

        Args:
            signals: List of signals

        Returns:
            Combined signal or None
        """
        if not signals:
            return None

        # Group by symbol
        symbol_signals: dict[str, list[Signal]] = {}

        for signal in signals:
            if signal.symbol not in symbol_signals:
                symbol_signals[signal.symbol] = []
            symbol_signals[signal.symbol].append(signal)

        # Vote on each symbol
        combined_signals = []

        for symbol, sig_list in symbol_signals.items():
            # Count signal types
            buy_count = sum(1 for s in sig_list if s.signal_type == SignalType.BUY)
            sell_count = sum(1 for s in sig_list if s.signal_type == SignalType.SELL)
            close_count = sum(1 for s in sig_list if s.signal_type in
                            [SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT])

            # Weighted average confidence
            avg_confidence = sum(s.confidence for s in sig_list) / len(sig_list)

            # Determine consensus
            if buy_count > len(sig_list) / 2:
                # Majority buy
                best_signal = max((s for s in sig_list if s.signal_type == SignalType.BUY),
                                key=lambda s: s.confidence)

                combined = Signal(
                    strategy_name="consensus",
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=avg_confidence,
                    timestamp=datetime.utcnow(),
                    price=best_signal.price,
                    stop_loss=best_signal.stop_loss,
                    take_profit=best_signal.take_profit,
                    reason=f"Consensus buy ({buy_count}/{len(sig_list)} strategies)",
                    metadata={'strategies': [s.strategy_name for s in sig_list]}
                )
                combined_signals.append(combined)

            elif close_count > len(sig_list) / 2:
                # Majority close
                best_signal = sig_list[0]

                combined = Signal(
                    strategy_name="consensus",
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=avg_confidence,
                    timestamp=datetime.utcnow(),
                    price=best_signal.price,
                    reason=f"Consensus close ({close_count}/{len(sig_list)} strategies)",
                    metadata={'strategies': [s.strategy_name for s in sig_list]}
                )
                combined_signals.append(combined)

        # Return highest confidence combined signal
        if combined_signals:
            return max(combined_signals, key=lambda s: s.confidence)

        return None

    def get_strategy_stats(self, name: str) -> dict[str, Any]:
        """Get strategy statistics.

        Args:
            name: Strategy name

        Returns:
            Strategy statistics
        """
        if name not in self.strategies:
            return {}

        strategy = self.strategies[name]
        signal_history = list(strategy.signal_history)

        return {
            'name': name,
            'type': strategy.config.strategy_type.value,
            'active': strategy.state.is_active,
            'positions': strategy.state.positions,
            'total_signals': len(signal_history),
            'last_signal': strategy.state.last_signal.signal_type.value
                          if strategy.state.last_signal else None,
            'last_update': strategy.state.last_update.isoformat()
                          if strategy.state.last_update else None
        }

    def signal_to_order(self, signal: Signal) -> OrderRequest:
        """Convert signal to order request.

        Args:
            signal: Trading signal

        Returns:
            Order request
        """
        # Determine order type
        if signal.stop_loss and signal.take_profit:
            order_type = OrderType.LIMIT
            limit_price = signal.price
        else:
            order_type = OrderType.MARKET
            limit_price = None

        # Map signal to order side
        if signal.signal_type in [SignalType.BUY]:
            side = OrderSide.BUY
        elif signal.signal_type in [SignalType.SELL, SignalType.CLOSE_LONG]:
            side = OrderSide.SELL
        else:
            raise ValueError(f"Cannot convert signal type: {signal.signal_type}")

        return OrderRequest(
            symbol=signal.symbol,
            side=side,
            order_type=order_type,
            quantity=signal.quantity or 100,  # Default quantity
            limit_price=limit_price,
            stop_price=signal.stop_loss,
            time_in_force=TimeInForce.DAY,
            strategy_name=signal.strategy_name,
            signal_confidence=signal.confidence,
            notes=signal.reason
        )