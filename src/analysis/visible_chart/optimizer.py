"""Fast Optimizer for Entry Signal Optimization.

Implements random search with early stopping to find optimal
indicator sets within a time budget (1-3 seconds).

Phase 2.5: Fast Optimizer (UI/Visible Window) im Worker
"""

from __future__ import annotations

import logging
import random
import time
from dataclasses import dataclass, field
from typing import Any, Callable

from .indicator_families import (
    IndicatorConfig,
    OptimizableSet,
    get_candidates_for_regime,
)
from .objective import ObjectiveFunction, ObjectiveResult, create_objective_for_regime
from .trade_simulator import SimulationConfig, SimulationResult, TradeSimulator
from .types import AnalysisResult, EntryEvent, EntrySide, IndicatorSet, RegimeType

logger = logging.getLogger(__name__)


@dataclass
class OptimizerConfig:
    """Configuration for the optimizer.

    Attributes:
        time_budget_ms: Maximum time for optimization in milliseconds.
        max_iterations: Maximum number of random samples.
        early_stop_no_improve: Stop after N iterations without improvement.
        top_k: Number of top sets to return.
        min_indicators: Minimum indicators per set.
        max_indicators: Maximum indicators per set.
        cache_enabled: Whether to use feature cache.
    """

    time_budget_ms: float = 2000.0  # 2 seconds
    max_iterations: int = 100
    early_stop_no_improve: int = 20
    top_k: int = 3
    min_indicators: int = 1
    max_indicators: int = 3
    cache_enabled: bool = True


@dataclass
class OptimizationResult:
    """Result of optimization run.

    Attributes:
        best_set: Best indicator set found.
        alternatives: Top-K alternative sets.
        iterations: Number of iterations run.
        time_ms: Time taken in milliseconds.
        best_score: Score of best set.
        entries: Entry signals generated by best set.
    """

    best_set: IndicatorSet | None = None
    alternatives: list[IndicatorSet] = field(default_factory=list)
    iterations: int = 0
    time_ms: float = 0.0
    best_score: float = float("-inf")
    entries: list[EntryEvent] = field(default_factory=list)


class FastOptimizer:
    """Fast optimizer using random search with early stopping.

    Designed to run within UI time budget (1-3 seconds) while
    finding effective indicator parameter combinations.
    """

    def __init__(self, config: OptimizerConfig | None = None) -> None:
        """Initialize the optimizer.

        Args:
            config: Optimizer configuration.
        """
        self.config = config or OptimizerConfig()
        self._feature_cache: dict[str, Any] = {}

    def optimize(
        self,
        candles: list[dict],
        regime: RegimeType,
        features: dict[str, list[float]] | None = None,
    ) -> OptimizationResult:
        """Run optimization to find best indicator set.

        Args:
            candles: OHLCV candle data for the visible range.
            regime: Detected market regime.
            features: Pre-calculated features (optional).

        Returns:
            OptimizationResult with best set and alternatives.
        """
        start_time = time.perf_counter()
        deadline = start_time + (self.config.time_budget_ms / 1000)

        # Get candidates for this regime
        candidates = get_candidates_for_regime(regime.value)
        if not candidates:
            logger.warning("No candidates for regime %s", regime.value)
            return OptimizationResult()

        # Create objective function for regime
        objective = create_objective_for_regime(regime.value)

        # Create simulator
        simulator = TradeSimulator(SimulationConfig())

        # Calculate hours for signal rate
        if candles:
            hours = (candles[-1]["timestamp"] - candles[0]["timestamp"]) / 3600
        else:
            hours = 1.0

        # Track results
        results: list[tuple[float, OptimizableSet, ObjectiveResult, list[EntryEvent]]] = []
        best_score = float("-inf")
        no_improve_count = 0
        iterations = 0

        # Random search
        for i in range(self.config.max_iterations):
            # Check time budget
            if time.perf_counter() > deadline:
                logger.debug("Time budget exceeded after %d iterations", i)
                break

            iterations = i + 1

            # Sample random set
            opt_set = self._sample_random_set(candidates)

            # Generate entries using sampled indicators
            entries = self._generate_entries(candles, opt_set, regime, features)

            if not entries:
                # Debug first few failures
                if i < 5:
                    try:
                        from .debug_logger import debug_logger
                        debug_logger.debug("Iteration %d: No entries generated with %d indicators", i, len(opt_set.indicators))
                    except ImportError:
                        pass
                continue

            # Simulate trades
            sim_result = simulator.simulate(entries, candles, features)

            # Evaluate with objective
            obj_result = objective.evaluate(
                sim_result,
                n_indicators=len(opt_set.indicators),
                hours_analyzed=hours,
            )

            if not obj_result.is_valid:
                # Debug first few validation failures
                if len(results) < 3:
                    try:
                        from .debug_logger import debug_logger
                        debug_logger.debug("Iteration %d: Entries generated (%d) but failed validation (reason: %s)",
                                         i, len(entries), obj_result.reason if hasattr(obj_result, 'reason') else 'unknown')
                    except ImportError:
                        pass
                continue

            # Track result
            results.append((obj_result.score, opt_set, obj_result, entries))

            # Update best
            if obj_result.score > best_score:
                best_score = obj_result.score
                no_improve_count = 0
            else:
                no_improve_count += 1

            # Early stopping
            if no_improve_count >= self.config.early_stop_no_improve:
                logger.debug("Early stop after %d iterations (no improvement)", i)
                break

        elapsed_ms = (time.perf_counter() - start_time) * 1000

        # Sort by score and get top-K
        results.sort(key=lambda x: -x[0])
        top_results = results[: self.config.top_k]

        if not top_results:
            logger.warning("No valid sets found in %d iterations for regime %s", iterations, regime.value)
            # Debug: Log why no results were found
            try:
                from .debug_logger import debug_logger
                debug_logger.warning("OPTIMIZER: No valid indicator sets found!")
                debug_logger.info("  Regime: %s", regime.value)
                debug_logger.info("  Iterations: %d", iterations)
                debug_logger.info("  Candidates available: %d", len(candidates))
                debug_logger.info("  Total results generated: %d", len(results))
                debug_logger.info("  Time budget: %.1fms (used: %.1fms)", self.config.time_budget_ms, elapsed_ms)
                if not results:
                    debug_logger.warning("  No entries generated at all - check _generate_entries() logic for %s regime", regime.value)
            except ImportError:
                pass
            return OptimizationResult(iterations=iterations, time_ms=elapsed_ms)

        # Build result
        best = top_results[0]
        best_indicator_set = best[1].to_indicator_set(
            name=self._generate_set_name(best[1]),
            regime=regime.value,
            score=best[0],
        )

        alternatives = [
            r[1].to_indicator_set(
                name=self._generate_set_name(r[1]),
                regime=regime.value,
                score=r[0],
            )
            for r in top_results[1:]
        ]

        logger.info(
            "Optimization complete: score=%.3f, iterations=%d, time=%.1fms",
            best[0],
            iterations,
            elapsed_ms,
        )

        return OptimizationResult(
            best_set=best_indicator_set,
            alternatives=alternatives,
            iterations=iterations,
            time_ms=elapsed_ms,
            best_score=best[0],
            entries=best[3],
        )

    def _sample_random_set(
        self, candidates: list[IndicatorConfig]
    ) -> OptimizableSet:
        """Sample a random indicator set.

        Args:
            candidates: Available indicator configs.

        Returns:
            Randomly configured OptimizableSet.
        """
        # Random number of indicators
        n = random.randint(self.config.min_indicators, self.config.max_indicators)
        n = min(n, len(candidates))

        # Sample indicators without replacement
        selected = random.sample(candidates, n)

        # Randomize parameters for each
        indicators = []
        weights = {}

        for config in selected:
            params = config.randomize_params()
            indicators.append((config, params))
            weights[config.name] = random.uniform(*config.weight_range)

        # Random postprocess config
        postprocess = {
            "cooldown_minutes": random.randint(3, 10),
            "max_signals_per_hour": random.randint(4, 10),
            "min_confidence": random.uniform(0.4, 0.7),
        }

        # Random stop config
        stop = {
            "atr_multiplier": random.uniform(1.5, 3.0),
            "max_risk_pct": random.uniform(0.5, 1.5),
        }

        return OptimizableSet(
            indicators=indicators,
            scoring_weights=weights,
            postprocess_config=postprocess,
            stop_config=stop,
        )

    def _generate_entries(
        self,
        candles: list[dict],
        opt_set: OptimizableSet,
        regime: RegimeType,
        features: dict[str, list[float]] | None,
    ) -> list[EntryEvent]:
        """Generate entry signals using indicator set.

        This is a simplified signal generator that uses the
        indicator parameters to filter entries.

        Args:
            candles: Candle data.
            opt_set: Optimizable set with indicators.
            regime: Market regime.
            features: Pre-calculated features.

        Returns:
            List of entry events.
        """
        if not candles or len(candles) < 20:
            return []

        # Prepare context
        context = self._prepare_generation_context(candles, opt_set, features)

        # Generate raw entries
        raw_entries = self._generate_raw_entries_loop(
            candles, context, regime, opt_set
        )

        # Apply postprocessing
        entries = self._postprocess_entries(raw_entries, opt_set.postprocess_config)

        return entries

    def _prepare_generation_context(
        self,
        candles: list[dict],
        opt_set: OptimizableSet,
        features: dict[str, list[float]] | None,
    ) -> dict:
        """Prepare context data for entry generation."""
        # Calculate basic features if not provided
        if features is None:
            features = self._calculate_basic_features(candles)

        # Get indicator parameters
        indicator_params = {cfg.name: params for cfg, params in opt_set.indicators}

        # Extract thresholds from indicator parameters
        rsi_oversold = 30
        rsi_overbought = 70
        trend_threshold = 0.005

        if "RSI" in indicator_params:
            rsi_oversold = indicator_params["RSI"].get("oversold", 30)
            rsi_overbought = indicator_params["RSI"].get("overbought", 70)

        if "EMA_Trend" in indicator_params:
            trend_threshold = indicator_params["EMA_Trend"].get("threshold", 0.005)

        return {
            "closes": [c["close"] for c in candles],
            "price_vs_sma": features.get("price_vs_sma", []),
            "volatility": features.get("volatility", []),
            "rsi_oversold": rsi_oversold,
            "rsi_overbought": rsi_overbought,
            "trend_threshold": trend_threshold,
            "min_confidence": opt_set.postprocess_config.get("min_confidence", 0.5),
            "scoring_weights": opt_set.scoring_weights,
        }

    def _generate_raw_entries_loop(
        self,
        candles: list[dict],
        context: dict,
        regime: RegimeType,
        opt_set: OptimizableSet,
    ) -> list[EntryEvent]:
        """Main loop for generating raw entry signals."""
        entries = []

        for i, candle in enumerate(candles):
            if i < 20:  # Skip warmup
                continue

            entry = self._check_entry_at_candle(i, candle, context, regime, opt_set)
            if entry:
                entries.append(entry)

        return entries

    def _check_entry_at_candle(
        self,
        i: int,
        candle: dict,
        context: dict,
        regime: RegimeType,
        opt_set: OptimizableSet,
    ) -> EntryEvent | None:
        """Check for entry signal at specific candle index."""
        trend = context["price_vs_sma"][i] if i < len(context["price_vs_sma"]) else 0
        vol = context["volatility"][i] if i < len(context["volatility"]) else 0

        # Route to regime-specific handler
        handlers = {
            RegimeType.TREND_UP: self._handle_trend_up_entry,
            RegimeType.TREND_DOWN: self._handle_trend_down_entry,
            RegimeType.RANGE: self._handle_range_entry,
            RegimeType.SQUEEZE: self._handle_squeeze_entry,
        }

        handler = handlers.get(regime)
        if not handler:
            return None

        bar_data = {"trend": trend, "vol": vol, "i": i, "closes": context["closes"]}
        result = handler(bar_data, context)

        if not result:
            return None

        score, side, reasons = result

        # Apply indicator weights to score
        for name, weight in context["scoring_weights"].items():
            score *= (1 + (weight - 0.5) * 0.2)

        # Check threshold
        if score >= context["min_confidence"]:
            return EntryEvent(
                timestamp=candle["timestamp"],
                side=side,
                confidence=min(score, 1.0),
                price=candle["close"],
                reason_tags=reasons,
                regime=regime,
            )

        return None

    def _handle_trend_up_entry(
        self, bar_data: dict, context: dict
    ) -> tuple[float, EntrySide, list[str]] | None:
        """Handle TREND_UP regime: long on pullback."""
        trend = bar_data["trend"]
        trend_threshold = context["trend_threshold"]

        if trend > 0 and trend < trend_threshold * 2:
            score = 0.5 + abs(trend) * 20
            return (score, EntrySide.LONG, ["trend_pullback"])
        return None

    def _handle_trend_down_entry(
        self, bar_data: dict, context: dict
    ) -> tuple[float, EntrySide, list[str]] | None:
        """Handle TREND_DOWN regime: short on pullback."""
        trend = bar_data["trend"]
        trend_threshold = context["trend_threshold"]

        if trend < 0 and trend > -trend_threshold * 2:
            score = 0.5 + abs(trend) * 20
            return (score, EntrySide.SHORT, ["trend_pullback"])
        return None

    def _handle_range_entry(
        self, bar_data: dict, context: dict
    ) -> tuple[float, EntrySide, list[str]] | None:
        """Handle RANGE regime: mean reversion at extremes."""
        trend = bar_data["trend"]
        threshold = context["trend_threshold"] * 1.5

        if trend < -threshold:
            score = 0.5 + abs(trend) * 25
            return (score, EntrySide.LONG, ["oversold"])
        elif trend > threshold:
            score = 0.5 + abs(trend) * 25
            return (score, EntrySide.SHORT, ["overbought"])
        return None

    def _handle_squeeze_entry(
        self, bar_data: dict, context: dict
    ) -> tuple[float, EntrySide, list[str]] | None:
        """Handle SQUEEZE regime: range breakouts with very loose conditions."""
        i = bar_data["i"]
        trend = bar_data["trend"]
        closes = bar_data["closes"]

        # Debug logging for first iteration
        self._log_squeeze_debug(i, bar_data)

        # Calculate local range
        recent_prices = closes[max(0, i-20):i+1]
        if len(recent_prices) < 5:
            return None

        local_high = max(recent_prices)
        local_low = min(recent_prices)
        current_price = closes[i]

        if local_high <= local_low:
            return None

        # Position in range (0 = low, 1 = high)
        position = (current_price - local_low) / (local_high - local_low)

        # Debug logging for early checks
        if i < 23:
            self._log_squeeze_position(i, position, trend, current_price)

        # Very loose conditions for testing
        if position < 0.4:
            score = 0.51 + (0.4 - position) * 0.5  # 0.51-0.71
            return (score, EntrySide.LONG, ["squeeze_range_low"])
        elif position > 0.6:
            score = 0.51 + (position - 0.6) * 0.5  # 0.51-0.71
            return (score, EntrySide.SHORT, ["squeeze_range_high"])
        elif 0.35 < position < 0.65:
            if trend > 0.0001:  # Very minimal
                score = 0.51 + abs(trend) * 50
                return (score, EntrySide.LONG, ["squeeze_trend_long"])
            elif trend < -0.0001:
                score = 0.51 + abs(trend) * 50
                return (score, EntrySide.SHORT, ["squeeze_trend_short"])

        return None

    def _log_squeeze_debug(self, i: int, bar_data: dict) -> None:
        """Log debug info for squeeze regime at first iteration."""
        if i != 20:
            return

        try:
            from .debug_logger import debug_logger
            debug_logger.warning("=" * 60)
            debug_logger.warning("SQUEEZE ITERATION DEBUG (i=20)")
            debug_logger.warning("  trend: %.6f", bar_data["trend"])
            debug_logger.warning("  vol: %.6f", bar_data["vol"])
            debug_logger.warning("  closes[i]: %.2f",
                bar_data["closes"][i] if i < len(bar_data["closes"]) else 0)
            debug_logger.warning("=" * 60)
        except Exception:
            pass

    def _log_squeeze_position(
        self, i: int, position: float, trend: float, price: float
    ) -> None:
        """Log position info for squeeze regime during early checks."""
        try:
            from .debug_logger import debug_logger
            debug_logger.info("  i=%d: position=%.3f, trend=%.6f, price=%.2f",
                            i, position, trend, price)
        except Exception:
            pass

    def _calculate_basic_features(
        self, candles: list[dict]
    ) -> dict[str, list[float]]:
        """Calculate basic features for signal generation.

        Args:
            candles: OHLCV data.

        Returns:
            Dict of feature arrays.
        """
        if len(candles) < 20:
            return {}

        closes = [c["close"] for c in candles]

        # SMA-20
        sma_20 = []
        for i in range(len(closes)):
            if i < 19:
                sma_20.append(closes[i])
            else:
                sma_20.append(sum(closes[i - 19 : i + 1]) / 20)

        # Price vs SMA
        price_vs_sma = [
            (closes[i] - sma_20[i]) / sma_20[i] if sma_20[i] != 0 else 0
            for i in range(len(closes))
        ]

        # Volatility (TR/Close)
        volatility = []
        for c in candles:
            tr = c["high"] - c["low"]
            volatility.append(tr / c["close"] if c["close"] != 0 else 0)

        return {
            "sma_20": sma_20,
            "price_vs_sma": price_vs_sma,
            "volatility": volatility,
            "closes": closes,
        }

    def _postprocess_entries(
        self, entries: list[EntryEvent], config: dict
    ) -> list[EntryEvent]:
        """Apply postprocessing rules to entries.

        Args:
            entries: Raw entries.
            config: Postprocess configuration.

        Returns:
            Filtered entries.
        """
        if not entries:
            return entries

        # Sort by timestamp
        entries = sorted(entries, key=lambda e: e.timestamp)

        # Apply cooldown
        cooldown_sec = config.get("cooldown_minutes", 5) * 60
        filtered = []
        last_ts = 0

        for entry in entries:
            if entry.timestamp - last_ts >= cooldown_sec:
                filtered.append(entry)
                last_ts = entry.timestamp

        # Rate limiting
        max_per_hour = config.get("max_signals_per_hour", 6)
        if len(filtered) > max_per_hour:
            filtered = sorted(filtered, key=lambda e: -e.confidence)[:max_per_hour]
            filtered = sorted(filtered, key=lambda e: e.timestamp)

        return filtered

    def _generate_set_name(self, opt_set: OptimizableSet) -> str:
        """Generate a descriptive name for the set.

        Args:
            opt_set: The optimizable set.

        Returns:
            Human-readable name.
        """
        if not opt_set.indicators:
            return "Empty Set"

        names = [cfg.name for cfg, _ in opt_set.indicators[:2]]
        return " + ".join(names)

    def clear_cache(self) -> None:
        """Clear the feature cache."""
        self._feature_cache.clear()
