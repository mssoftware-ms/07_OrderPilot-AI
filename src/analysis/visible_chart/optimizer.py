"""Fast Optimizer for Entry Signal Optimization.

Implements random search with early stopping to find optimal
indicator sets within a time budget (1-3 seconds).

Phase 2.5: Fast Optimizer (UI/Visible Window) im Worker
"""

from __future__ import annotations

import logging
import random
import time
from dataclasses import dataclass, field
from typing import Any, Callable

from .indicator_families import (
    IndicatorConfig,
    OptimizableSet,
    get_candidates_for_regime,
)
from .objective import ObjectiveFunction, ObjectiveResult, create_objective_for_regime
from .trade_simulator import SimulationConfig, SimulationResult, TradeSimulator
from .types import AnalysisResult, EntryEvent, EntrySide, IndicatorSet, RegimeType

logger = logging.getLogger(__name__)


@dataclass
class OptimizerConfig:
    """Configuration for the optimizer.

    Attributes:
        time_budget_ms: Maximum time for optimization in milliseconds.
        max_iterations: Maximum number of random samples.
        early_stop_no_improve: Stop after N iterations without improvement.
        top_k: Number of top sets to return.
        min_indicators: Minimum indicators per set.
        max_indicators: Maximum indicators per set.
        cache_enabled: Whether to use feature cache.
    """

    time_budget_ms: float = 2000.0  # 2 seconds
    max_iterations: int = 100
    early_stop_no_improve: int = 20
    top_k: int = 3
    min_indicators: int = 1
    max_indicators: int = 3
    cache_enabled: bool = True


@dataclass
class OptimizationResult:
    """Result of optimization run.

    Attributes:
        best_set: Best indicator set found.
        alternatives: Top-K alternative sets.
        iterations: Number of iterations run.
        time_ms: Time taken in milliseconds.
        best_score: Score of best set.
        entries: Entry signals generated by best set.
    """

    best_set: IndicatorSet | None = None
    alternatives: list[IndicatorSet] = field(default_factory=list)
    iterations: int = 0
    time_ms: float = 0.0
    best_score: float = float("-inf")
    entries: list[EntryEvent] = field(default_factory=list)


class FastOptimizer:
    """Fast optimizer using random search with early stopping.

    Designed to run within UI time budget (1-3 seconds) while
    finding effective indicator parameter combinations.
    """

    def __init__(self, config: OptimizerConfig | None = None) -> None:
        """Initialize the optimizer.

        Args:
            config: Optimizer configuration.
        """
        self.config = config or OptimizerConfig()
        self._feature_cache: dict[str, Any] = {}

    def optimize(
        self,
        candles: list[dict],
        regime: RegimeType,
        features: dict[str, list[float]] | None = None,
    ) -> OptimizationResult:
        """Run optimization to find best indicator set.

        Args:
            candles: OHLCV candle data for the visible range.
            regime: Detected market regime.
            features: Pre-calculated features (optional).

        Returns:
            OptimizationResult with best set and alternatives.
        """
        start_time = time.perf_counter()
        deadline = start_time + (self.config.time_budget_ms / 1000)

        # Get candidates for this regime
        candidates = get_candidates_for_regime(regime.value)
        if not candidates:
            logger.warning("No candidates for regime %s", regime.value)
            return OptimizationResult()

        # Create objective function for regime
        objective = create_objective_for_regime(regime.value)

        # Create simulator
        simulator = TradeSimulator(SimulationConfig())

        # Calculate hours for signal rate
        if candles:
            hours = (candles[-1]["timestamp"] - candles[0]["timestamp"]) / 3600
        else:
            hours = 1.0

        # Track results
        results: list[tuple[float, OptimizableSet, ObjectiveResult, list[EntryEvent]]] = []
        best_score = float("-inf")
        no_improve_count = 0
        iterations = 0

        # Random search
        for i in range(self.config.max_iterations):
            # Check time budget
            if time.perf_counter() > deadline:
                logger.debug("Time budget exceeded after %d iterations", i)
                break

            iterations = i + 1

            # Sample random set
            opt_set = self._sample_random_set(candidates)

            # Generate entries using sampled indicators
            entries = self._generate_entries(candles, opt_set, regime, features)

            if not entries:
                # Debug first few failures
                if i < 5:
                    try:
                        from .debug_logger import debug_logger
                        debug_logger.debug("Iteration %d: No entries generated with %d indicators", i, len(opt_set.indicators))
                    except ImportError:
                        pass
                continue

            # Simulate trades
            sim_result = simulator.simulate(entries, candles, features)

            # Evaluate with objective
            obj_result = objective.evaluate(
                sim_result,
                n_indicators=len(opt_set.indicators),
                hours_analyzed=hours,
            )

            if not obj_result.is_valid:
                # Debug first few validation failures
                if len(results) < 3:
                    try:
                        from .debug_logger import debug_logger
                        debug_logger.debug("Iteration %d: Entries generated (%d) but failed validation (reason: %s)",
                                         i, len(entries), obj_result.reason if hasattr(obj_result, 'reason') else 'unknown')
                    except ImportError:
                        pass
                continue

            # Track result
            results.append((obj_result.score, opt_set, obj_result, entries))

            # Update best
            if obj_result.score > best_score:
                best_score = obj_result.score
                no_improve_count = 0
            else:
                no_improve_count += 1

            # Early stopping
            if no_improve_count >= self.config.early_stop_no_improve:
                logger.debug("Early stop after %d iterations (no improvement)", i)
                break

        elapsed_ms = (time.perf_counter() - start_time) * 1000

        # Sort by score and get top-K
        results.sort(key=lambda x: -x[0])
        top_results = results[: self.config.top_k]

        if not top_results:
            logger.warning("No valid sets found in %d iterations for regime %s", iterations, regime.value)
            # Debug: Log why no results were found
            try:
                from .debug_logger import debug_logger
                debug_logger.warning("OPTIMIZER: No valid indicator sets found!")
                debug_logger.info("  Regime: %s", regime.value)
                debug_logger.info("  Iterations: %d", iterations)
                debug_logger.info("  Candidates available: %d", len(candidates))
                debug_logger.info("  Total results generated: %d", len(results))
                debug_logger.info("  Time budget: %.1fms (used: %.1fms)", self.config.time_budget_ms, elapsed_ms)
                if not results:
                    debug_logger.warning("  No entries generated at all - check _generate_entries() logic for %s regime", regime.value)
            except ImportError:
                pass
            return OptimizationResult(iterations=iterations, time_ms=elapsed_ms)

        # Build result
        best = top_results[0]
        best_indicator_set = best[1].to_indicator_set(
            name=self._generate_set_name(best[1]),
            regime=regime.value,
            score=best[0],
        )

        alternatives = [
            r[1].to_indicator_set(
                name=self._generate_set_name(r[1]),
                regime=regime.value,
                score=r[0],
            )
            for r in top_results[1:]
        ]

        logger.info(
            "Optimization complete: score=%.3f, iterations=%d, time=%.1fms",
            best[0],
            iterations,
            elapsed_ms,
        )

        return OptimizationResult(
            best_set=best_indicator_set,
            alternatives=alternatives,
            iterations=iterations,
            time_ms=elapsed_ms,
            best_score=best[0],
            entries=best[3],
        )

    def _sample_random_set(
        self, candidates: list[IndicatorConfig]
    ) -> OptimizableSet:
        """Sample a random indicator set.

        Args:
            candidates: Available indicator configs.

        Returns:
            Randomly configured OptimizableSet.
        """
        # Random number of indicators
        n = random.randint(self.config.min_indicators, self.config.max_indicators)
        n = min(n, len(candidates))

        # Sample indicators without replacement
        selected = random.sample(candidates, n)

        # Randomize parameters for each
        indicators = []
        weights = {}

        for config in selected:
            params = config.randomize_params()
            indicators.append((config, params))
            weights[config.name] = random.uniform(*config.weight_range)

        # Random postprocess config
        postprocess = {
            "cooldown_minutes": random.randint(3, 10),
            "max_signals_per_hour": random.randint(4, 10),
            "min_confidence": random.uniform(0.4, 0.7),
        }

        # Random stop config
        stop = {
            "atr_multiplier": random.uniform(1.5, 3.0),
            "max_risk_pct": random.uniform(0.5, 1.5),
        }

        return OptimizableSet(
            indicators=indicators,
            scoring_weights=weights,
            postprocess_config=postprocess,
            stop_config=stop,
        )

    def _generate_entries(
        self,
        candles: list[dict],
        opt_set: OptimizableSet,
        regime: RegimeType,
        features: dict[str, list[float]] | None,
    ) -> list[EntryEvent]:
        """Generate entry signals using indicator set.

        This is a simplified signal generator that uses the
        indicator parameters to filter entries.

        Args:
            candles: Candle data.
            opt_set: Optimizable set with indicators.
            regime: Market regime.
            features: Pre-calculated features.

        Returns:
            List of entry events.
        """
        if not candles or len(candles) < 20:
            return []

        entries = []
        closes = [c["close"] for c in candles]

        # Calculate basic features if not provided
        if features is None:
            features = self._calculate_basic_features(candles)

        price_vs_sma = features.get("price_vs_sma", [])
        volatility = features.get("volatility", [])

        # Get indicator parameters
        indicator_params = {cfg.name: params for cfg, params in opt_set.indicators}

        # Extract thresholds from indicator parameters
        rsi_oversold = 30
        rsi_overbought = 70
        trend_threshold = 0.005

        if "RSI" in indicator_params:
            rsi_oversold = indicator_params["RSI"].get("oversold", 30)
            rsi_overbought = indicator_params["RSI"].get("overbought", 70)

        if "EMA_Trend" in indicator_params:
            trend_threshold = indicator_params["EMA_Trend"].get("threshold", 0.005)

        min_confidence = opt_set.postprocess_config.get("min_confidence", 0.5)

        # Simple rule-based entry generation
        for i, candle in enumerate(candles):
            if i < 20:  # Skip warmup
                continue

            score = 0.0
            side = None
            reasons = []

            trend = price_vs_sma[i] if i < len(price_vs_sma) else 0
            vol = volatility[i] if i < len(volatility) else 0

            # Regime-specific logic
            if regime in (RegimeType.TREND_UP,):
                # Long on pullback in uptrend
                if trend > 0 and trend < trend_threshold * 2:
                    score = 0.5 + abs(trend) * 20
                    side = EntrySide.LONG
                    reasons.append("trend_pullback")

            elif regime == RegimeType.TREND_DOWN:
                # Short on pullback in downtrend
                if trend < 0 and trend > -trend_threshold * 2:
                    score = 0.5 + abs(trend) * 20
                    side = EntrySide.SHORT
                    reasons.append("trend_pullback")

            elif regime == RegimeType.RANGE:
                # Mean reversion at extremes
                threshold = trend_threshold * 1.5
                if trend < -threshold:
                    score = 0.5 + abs(trend) * 25
                    side = EntrySide.LONG
                    reasons.append("oversold")
                elif trend > threshold:
                    score = 0.5 + abs(trend) * 25
                    side = EntrySide.SHORT
                    reasons.append("overbought")

            elif regime == RegimeType.SQUEEZE:
                # SUPER AGGRESSIVE DEBUG for SQUEEZE
                if i == 20:
                    try:
                        from .debug_logger import debug_logger
                        debug_logger.warning("=" * 60)
                        debug_logger.warning("SQUEEZE ITERATION DEBUG (i=20)")
                        debug_logger.warning("  trend: %.6f", trend)
                        debug_logger.warning("  vol: %.6f", vol)
                        debug_logger.warning("  closes[i]: %.2f", closes[i] if i < len(closes) else 0)
                        debug_logger.warning("=" * 60)
                    except Exception as e:
                        pass

                # SQUEEZE: SEHR LOCKERE Bedingungen für Testing!
                # Calculate local range
                recent_prices = closes[max(0, i-20):i+1]

                if len(recent_prices) >= 5:  # Nur 5 Kerzen benötigt
                    local_high = max(recent_prices)
                    local_low = min(recent_prices)
                    current_price = closes[i]

                    if local_high > local_low:
                        # Position in range (0 = low, 1 = high)
                        position = (current_price - local_low) / (local_high - local_low)

                        # DEBUG: Log für erste 3 Checks
                        if i < 23:
                            try:
                                from .debug_logger import debug_logger
                                debug_logger.info("  i=%d: position=%.3f, trend=%.6f, price=%.2f",
                                                i, position, trend, current_price)
                            except Exception:
                                pass

                        # EXTREM LOCKERE Bedingungen:
                        # 1. JEDE Position < 0.4 → LONG
                        if position < 0.4:
                            score = 0.51 + (0.4 - position) * 0.5  # 0.51-0.71
                            side = EntrySide.LONG
                            reasons.append("squeeze_range_low")
                        # 2. JEDE Position > 0.6 → SHORT
                        elif position > 0.6:
                            score = 0.51 + (position - 0.6) * 0.5  # 0.51-0.71
                            side = EntrySide.SHORT
                            reasons.append("squeeze_range_high")
                        # 3. Mitte mit MINIMALEM Trend
                        elif 0.35 < position < 0.65:
                            if trend > 0.0001:  # SEHR minimal
                                score = 0.51 + abs(trend) * 50
                                side = EntrySide.LONG
                                reasons.append("squeeze_trend_long")
                            elif trend < -0.0001:
                                score = 0.51 + abs(trend) * 50
                                side = EntrySide.SHORT
                                reasons.append("squeeze_trend_short")

            # Apply indicator weights to score
            for name, weight in opt_set.scoring_weights.items():
                score *= (1 + (weight - 0.5) * 0.2)

            # Add entry if threshold met
            if side and score >= min_confidence:
                entries.append(
                    EntryEvent(
                        timestamp=candle["timestamp"],
                        side=side,
                        confidence=min(score, 1.0),
                        price=candle["close"],
                        reason_tags=reasons,
                        regime=regime,
                    )
                )

        # Apply postprocessing
        entries = self._postprocess_entries(entries, opt_set.postprocess_config)

        return entries

    def _calculate_basic_features(
        self, candles: list[dict]
    ) -> dict[str, list[float]]:
        """Calculate basic features for signal generation.

        Args:
            candles: OHLCV data.

        Returns:
            Dict of feature arrays.
        """
        if len(candles) < 20:
            return {}

        closes = [c["close"] for c in candles]

        # SMA-20
        sma_20 = []
        for i in range(len(closes)):
            if i < 19:
                sma_20.append(closes[i])
            else:
                sma_20.append(sum(closes[i - 19 : i + 1]) / 20)

        # Price vs SMA
        price_vs_sma = [
            (closes[i] - sma_20[i]) / sma_20[i] if sma_20[i] != 0 else 0
            for i in range(len(closes))
        ]

        # Volatility (TR/Close)
        volatility = []
        for c in candles:
            tr = c["high"] - c["low"]
            volatility.append(tr / c["close"] if c["close"] != 0 else 0)

        return {
            "sma_20": sma_20,
            "price_vs_sma": price_vs_sma,
            "volatility": volatility,
            "closes": closes,
        }

    def _postprocess_entries(
        self, entries: list[EntryEvent], config: dict
    ) -> list[EntryEvent]:
        """Apply postprocessing rules to entries.

        Args:
            entries: Raw entries.
            config: Postprocess configuration.

        Returns:
            Filtered entries.
        """
        if not entries:
            return entries

        # Sort by timestamp
        entries = sorted(entries, key=lambda e: e.timestamp)

        # Apply cooldown
        cooldown_sec = config.get("cooldown_minutes", 5) * 60
        filtered = []
        last_ts = 0

        for entry in entries:
            if entry.timestamp - last_ts >= cooldown_sec:
                filtered.append(entry)
                last_ts = entry.timestamp

        # Rate limiting
        max_per_hour = config.get("max_signals_per_hour", 6)
        if len(filtered) > max_per_hour:
            filtered = sorted(filtered, key=lambda e: -e.confidence)[:max_per_hour]
            filtered = sorted(filtered, key=lambda e: e.timestamp)

        return filtered

    def _generate_set_name(self, opt_set: OptimizableSet) -> str:
        """Generate a descriptive name for the set.

        Args:
            opt_set: The optimizable set.

        Returns:
            Human-readable name.
        """
        if not opt_set.indicators:
            return "Empty Set"

        names = [cfg.name for cfg, _ in opt_set.indicators[:2]]
        return " + ".join(names)

    def clear_cache(self) -> None:
        """Clear the feature cache."""
        self._feature_cache.clear()
