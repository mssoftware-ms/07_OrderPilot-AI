
<!DOCTYPE html>
<!-- TEMPLATE VERSION: 2025-01-02-v2 -->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prefer local copy to avoid CDN/network failures -->
    <script src="assets/lightweight-charts.standalone.production.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-width: 0;
            min-height: 0;
        }
        #main-container {
            display: flex;
            width: 100%;
            height: 100%;
            min-width: 0;
            min-height: 0;
        }
        #drawing-toolbar {
            width: 36px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 4px 0;
            z-index: 1000;
        }
        .tool-btn {
            width: 32px;
            height: 32px;
            margin: 2px auto;
            border: none;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .tool-btn:hover { background: #333; }
        .tool-btn.active { background: #2962ff; }
        .tool-btn svg { width: 18px; height: 18px; }
        .tool-separator { height: 1px; background: #333; margin: 6px 4px; }
        #chart-container {
            flex: 1 1 auto;
            height: 100%;
            position: relative;
            min-width: 0;   /* allow flex child to shrink when chat dock is shown */
            min-height: 0;
        }
        #status { position: absolute; top: 10px; left: 10px; color: #00ff00; font-size: 12px; font-family: monospace; z-index: 1000; }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="drawing-toolbar">
            <button class="tool-btn active" id="tool-pointer" title="Auswahl (Esc)">
                <svg viewBox="0 0 24 24" fill="#aaa"><path d="M13.64 21.97C13.14 22.21 12.54 22 12.31 21.5L10.13 16.76L7.62 18.78C7.45 18.92 7.24 19 7 19C6.45 19 6 18.55 6 18V3C6 2.45 6.45 2 7 2C7.24 2 7.47 2.09 7.64 2.23L19.14 11.74C19.64 12.12 19.5 12.91 18.91 13.09L14.62 14.38L16.8 19.12C17.04 19.62 16.83 20.22 16.33 20.46L13.64 21.97Z"/></svg>
            </button>
            <div class="tool-separator"></div>
            <button class="tool-btn" id="tool-hline-green" title="Horizontale Linie (Grün)">
                <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12" stroke="#26a69a" stroke-width="3"/></svg>
            </button>
            <button class="tool-btn" id="tool-hline-red" title="Horizontale Linie (Rot)">
                <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12" stroke="#ef5350" stroke-width="3"/></svg>
            </button>
            <button class="tool-btn" id="tool-trendline" title="Trendlinie">
                <svg viewBox="0 0 24 24"><line x1="4" y1="18" x2="20" y2="6" stroke="#ffeb3b" stroke-width="2"/></svg>
            </button>
            <button class="tool-btn" id="tool-ray" title="Strahl">
                <svg viewBox="0 0 24 24"><line x1="4" y1="16" x2="20" y2="8" stroke="#9c27b0" stroke-width="2"/><circle cx="4" cy="16" r="3" fill="#9c27b0"/></svg>
            </button>
            <button class="tool-btn" id="tool-percent-rect" title="Prozent-Rechteck (% Differenz)">
                <svg viewBox="0 0 24 24"><rect x="4" y="6" width="16" height="12" fill="rgba(38,166,154,0.3)" stroke="#26a69a" stroke-width="1.5"/><text x="12" y="14" text-anchor="middle" fill="#26a69a" font-size="8" font-weight="bold">%</text></svg>
            </button>
            <button class="tool-btn" id="tool-rect-range" title="Preisbereich (volle Breite)">
                <svg viewBox="0 0 24 24">
                    <rect x="4" y="6" width="16" height="12" fill="rgba(13,110,253,0.18)" stroke="#0d6efd" stroke-width="1.5"/>
                </svg>
            </button>
            <button class="tool-btn" id="tool-fibonacci" title="Fibonacci Retracement">
                <svg viewBox="0 0 24 24">
                    <line x1="3" y1="4" x2="21" y2="4" stroke="#4CAF50" stroke-width="1.5"/>
                    <line x1="3" y1="8" x2="21" y2="8" stroke="#8BC34A" stroke-width="1"/>
                    <line x1="3" y1="12" x2="21" y2="12" stroke="#FFC107" stroke-width="1"/>
                    <line x1="3" y1="16" x2="21" y2="16" stroke="#FF9800" stroke-width="1"/>
                    <line x1="3" y1="20" x2="21" y2="20" stroke="#F44336" stroke-width="1.5"/>
                    <text x="12" y="14" text-anchor="middle" fill="#FFC107" font-size="6" font-weight="bold">FIB</text>
                </svg>
            </button>
            <div class="tool-separator"></div>
            <button class="tool-btn" id="tool-zoom-rect" title="Zoom-Auswahl (Bereich auswählen zum Zoomen)">
                <svg viewBox="0 0 24 24" fill="#2196F3"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/></svg>
            </button>
            <button class="tool-btn" id="tool-delete" title="Löschen (Del)">
                <svg viewBox="0 0 24 24" fill="#ef5350"><path d="M19 4h-3.5l-1-1h-5l-1 1H5v2h14M6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6v12z"/></svg>
            </button>
            <button class="tool-btn" id="tool-clear-all" title="Alle löschen">
                <svg viewBox="0 0 24 24" fill="#ff9800"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"/></svg>
            </button>
        </div>
        <div id="chart-container">
            <div id="status">Initializing chart...</div>
        </div>
    </div>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <script>
        const { createChart, CrosshairMode, LineStyle, LineSeries, HistogramSeries, CandlestickSeries, createSeriesMarkers } = LightweightCharts;

        // Global reference to Python bridge (set up after QWebChannel connects)
        let pyBridge = null;

        // Initialize QWebChannel for Python communication
        function initQtBridge() {
            if (typeof QWebChannel !== 'undefined' && typeof qt !== 'undefined' && qt.webChannelTransport) {
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    pyBridge = channel.objects.pyBridge;
                    console.log('QWebChannel connected, pyBridge available:', !!pyBridge);
                });
            } else {
                console.log('QWebChannel not available (running outside Qt?)');
            }
        }

        // Initialize bridge on load
        setTimeout(initQtBridge, 100);

        function initializeChart() {
            try {
                const container = document.getElementById('chart-container');
                const scaleMargins = { top: 0.15, bottom: 0.15 };
                // Get timezone offset for local time display (e.g., CET = +1, CEST = +2)
                const getLocalTimezoneOffsetHours = () => {
                    const now = new Date();
                    return -now.getTimezoneOffset() / 60;  // Offset in hours (positive for east of UTC)
                };
                const tzOffsetHours = getLocalTimezoneOffsetHours();
                console.log('Local timezone offset: UTC+' + tzOffsetHours);

                const chart = createChart(container, {
                    layout: {
                        background: { type: 'solid', color: '#0a0a0a' },
                        textColor: '#d1d4dc',
                        panes: { separatorColor: '#2a2a2a', separatorHoverColor: '#3a3a3a', enableResize: true },
                    },
                    grid: {
                        vertLines: { color: 'rgba(70, 70, 70, 0.35)' },
                        horzLines: { color: 'rgba(70, 70, 70, 0.35)' },
                    },
                    crosshair: { mode: CrosshairMode.Normal },
                    rightPriceScale: {
                        borderColor: '#485c7b',
                        minimumWidth: 60,
                        autoScale: true,
                        scaleMargins
                    },
                    timeScale: {
                        timeVisible: true,
                        secondsVisible: true,  // Issue #42: Show seconds on X-axis for 1S charts
                        borderColor: '#485c7b',
                        shiftVisibleRangeOnNewBar: false, // Issue: Chart springt zur Mitte - disabled
                        barSpacing: 10,  // Issue #8: Increased from 6 to 10 for better candle visibility on 1M/5M charts
                        minBarSpacing: 4, // Prevent ultra-thin candles when many bars are visible
                    },
                    localization: {
                        locale: 'de-DE',
                        // Timestamps are already shifted to local time in Python,
                        // so we use UTC methods to display them directly without double conversion
                        timeFormatter: (timestamp) => {
                            const date = new Date(timestamp * 1000);
                            const hours = String(date.getUTCHours()).padStart(2, '0');
                            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                            return `${hours}:${minutes}`;
                        },
                        dateFormatter: (timestamp) => {
                            const date = new Date(timestamp * 1000);
                            const day = String(date.getUTCDate()).padStart(2, '0');
                            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                            const year = date.getUTCFullYear();
                            return `${day}.${month}.${year}`;
                        },
                    },
                    handleScroll: {
                        mouseWheel: false,
                        pressedMouseMove: true,
                        horzTouchDrag: true,
                        vertTouchDrag: true,
                    },
                    handleScale: {
                        axisPressedMouseMove: { time: true, price: true },
                        mouseWheel: true,
                        pinch: true,
                    },
                    autoSize: true,
                });

                // Keep chart canvas in sync with container width/height (also fixes dock/undock)
                const resizeObserver = new ResizeObserver((entries) => {
                    const entry = entries?.[0];
                    if (!entry) return;
                    const width = Math.max(50, Math.floor(entry.contentRect.width));
                    const height = Math.max(50, Math.floor(entry.contentRect.height));
                    chart.resize(width, height);
                });
                resizeObserver.observe(container);

                const overlaySeries = {};
                const panelMap = {};
                const panelMainSeries = {};
                const panelExtraSeries = {};

                const pricePaneApi = chart.panes()[0];
                if (pricePaneApi?.setStretchFactor) pricePaneApi.setStretchFactor(10);

                const rightScale = chart.priceScale('right');
                let lastViewState = null; // Stores previous visible range + pane layout for undo

                // No extra drawing margin by default
                const DRAWING_MARGIN = 0;

                // Whitespace padding removed; drawing tools operate on real data range only.
                function extendVisibleRange() {
                    // no-op: keep API compatibility for callers
                    return;
                }

                function refitPriceScale() {
                    // Issue #8: Reset user's manual Y-panning preference when explicitly refitting
                    window._userDisabledAutoScale = false;
                    rightScale.applyOptions({ autoScale: true, scaleMargins });
                    chart.timeScale().fitContent();
                    // Use setTimeout to ensure fitContent has completed before extending
                    setTimeout(() => {
                        extendVisibleRange();
                        // Issue #4 Fix: Keep autoScale ON if streaming is active
                        if (window._streamingAutoScale !== true) {
                            rightScale.applyOptions({ autoScale: false, scaleMargins });
                        }
                    }, 50);
                }

                function snapshotViewState() {
                    try {
                        return {
                            visibleRange: chart.timeScale().getVisibleLogicalRange(),
                            paneLayout: window.chartAPI.getPaneLayout()
                        };
                    } catch (e) { console.error(e); return null; }
                }

                function rememberViewState() {
                    lastViewState = snapshotViewState();
                }

                function scalePaneLayout(zoomIn) {
                    try {
                        const layout = window.chartAPI.getPaneLayout();
                        const indicatorIds = Object.keys(layout || {}).filter(k => k !== 'price');
                        const priceFactor = layout?.price || 5;
                        const factor = zoomIn ? 1.1 : 0.9;
                        const indicatorFactor = zoomIn ? 1.05 : 0.95;
                        const newLayout = {};
                        newLayout['price'] = Math.max(2, priceFactor * factor);
                        indicatorIds.forEach(id => {
                            const current = layout[id] || 1;
                            newLayout[id] = Math.max(0.5, current * indicatorFactor);
                        });
                        window.chartAPI.setPaneLayout(newLayout);
                    } catch(e) { console.error(e); }
                }

                function normalizePaneHeights() {
                    try {
                        const layout = window.chartAPI.getPaneLayout();
                        const indicatorIds = Object.keys(layout || {}).filter(k => k !== 'price');
                        const newLayout = {};
                        if (indicatorIds.length) {
                            newLayout['price'] = 10;
                            // Each indicator gets stretchFactor 10 for 50% height (large panels)
                            indicatorIds.forEach(id => newLayout[id] = 10);
                        } else {
                            newLayout['price'] = 10;
                        }
                        window.chartAPI.setPaneLayout(newLayout);
                    } catch(e) { console.error(e); }
                }

                const priceSeries = chart.addSeries(CandlestickSeries, {
                    upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350'
                }, pricePaneApi.paneIndex());

                function addPane(panelId) {
                    if (panelMap[panelId] !== undefined) return panelMap[panelId];
                    const paneApi = chart.addPane();
                    // Set indicator pane height: stretchFactor 10 vs price pane 10 = 50%
                    // Large panels for better readability of RSI, MACD etc.
                    if (paneApi.setStretchFactor) {
                        paneApi.setStretchFactor(10);
                        console.log('Set stretchFactor 10 for pane:', panelId);
                    }
                    panelMap[panelId] = paneApi;

                    // Force layout update after adding pane
                    setTimeout(() => {
                        try {
                            const container = document.getElementById('chart-container');
                            if (container) {
                                chart.resize(container.clientWidth, container.clientHeight);
                            }
                        } catch(e) { console.error('Resize error:', e); }
                    }, 50);

                    return paneApi;
                }

                function removePane(panelId) {
                    const paneApi = panelMap[panelId];
                    if (!paneApi) return false;
                    if (paneApi === pricePaneApi) return false;

                    if (panelMainSeries[panelId]) {
                        chart.removeSeries(panelMainSeries[panelId]);
                        delete panelMainSeries[panelId];
                    }
                    Object.keys(panelExtraSeries).filter(k => k.startsWith(panelId + '_')).forEach(k => {
                        chart.removeSeries(panelExtraSeries[k]);
                        delete panelExtraSeries[k];
                    });

                    chart.removePane(paneApi.paneIndex());
                    delete panelMap[panelId];
                    return true;
                }

                // Global flag to suppress fitContent during state restoration
                let suppressFitContent = false;

                // Markers primitive holder (v5 API)
                let seriesMarkers = null;

                window.chartAPI = {
                    // Set data with optional skipFit parameter
                    setData: (data, skipFit = false) => {
                        try {
                            priceSeries.setData(data);

                            // Issue #39: Store candle data for rounded candles overlay
                            roundedCandlesData = data || [];

                            // Issue #39: Initialize rounded candles overlay after data is loaded
                            setTimeout(() => {
                                try {
                                    initRoundedCandlesOverlay();
                                    // Update overlay views to render the data
                                    if (roundedCandlesOverlay) {
                                        roundedCandlesOverlay.updateAllViews();
                                    }
                                } catch(e) {
                                    console.error('Failed to init rounded candles overlay:', e);
                                }
                            }, 100);

                            if (!skipFit && !suppressFitContent) {
                                refitPriceScale();
                            } else {
                                console.log('setData: skipping fitContent (skipFit=' + skipFit + ', suppressFitContent=' + suppressFitContent + ')');
                                // Still extend drawing area even when skipFit is true
                                setTimeout(() => extendVisibleRange(), 100);
                            }
                        } catch(e){ console.error(e); }
                    },

                    // Suppress fitContent calls during state restoration
                    setSuppressFitContent: (suppress) => {
                        suppressFitContent = suppress;
                        console.log('suppressFitContent set to:', suppress);
                    },
                    updateCandle: (c) => {
                        try {
                            // Track last update time to avoid "Cannot update oldest data" errors
                            if (window._lastCandleTime && c.time < window._lastCandleTime) {
                                return false;
                            }
                            priceSeries.update(c);
                            window._lastCandleTime = c.time;

                            // Issue #39: Update roundedCandlesData with new candle
                            if (roundedCandlesData.length > 0) {
                                const lastIndex = roundedCandlesData.length - 1;
                                if (roundedCandlesData[lastIndex] && roundedCandlesData[lastIndex].time === c.time) {
                                    // Update existing candle
                                    roundedCandlesData[lastIndex] = c;
                                } else {
                                    // Add new candle
                                    roundedCandlesData.push(c);
                                }
                            }

                            // Issue #39: Update rounded candles overlay on streaming updates
                            if (roundedCandlesOverlay) {
                                roundedCandlesOverlay.updateAllViews();
                            }

                            // Issue #4: Auto-fit Y scale during streaming to prevent flat candles
                            // Issue #8: BUT respect user's manual Y-panning - don't override if user disabled
                            if (window._streamingAutoScale !== false && window._userDisabledAutoScale !== true) {
                                rightScale.applyOptions({ autoScale: true });
                            }
                            return true;
                        } catch(e){
                            if (e.message && e.message.includes('oldest data')) return false;
                            console.error(e);
                            return false;
                        }
                    },
                    // Issue #4: Control auto-scaling during streaming
                    setStreamingAutoScale: (enabled) => {
                        window._streamingAutoScale = enabled;
                        if (enabled) {
                            rightScale.applyOptions({ autoScale: true });
                        }
                    },
                    // Issue #9: Re-enable volume chart with histogram series
                    setVolumeData: (data) => {
                        try {
                            if (!data || !Array.isArray(data) || data.length === 0) {
                                console.warn('setVolumeData: no data provided');
                                return false;
                            }

                            // Create or get volume panel
                            const panelId = 'volume';
                            const seriesKey = 'volume';

                            // Check if volume series already exists
                            const key = panelId + '_' + seriesKey;
                            if (!panelExtraSeries[key]) {
                                // Add volume as histogram series in separate panel
                                const success = window.chartAPI.addPanelSeries(
                                    panelId,
                                    seriesKey,
                                    'histogram',
                                    '#26a69a80',  // Semi-transparent green
                                    data
                                );
                                if (!success) {
                                    console.error('Failed to create volume series');
                                    return false;
                                }
                            } else {
                                // Update existing volume data
                                panelExtraSeries[key].setData(data);
                            }

                            console.log('Volume data set: ' + data.length + ' bars');
                            return true;
                        } catch(e) {
                            console.error('setVolumeData error:', e);
                            return false;
                        }
                    },
                    updateVolume: (volumeBar) => {
                        try {
                            if (!volumeBar || !volumeBar.time) {
                                return false;
                            }

                            const key = 'volume_volume';
                            const volumeSeries = panelExtraSeries[key];

                            if (!volumeSeries) {
                                console.warn('Volume series not initialized, call setVolumeData first');
                                return false;
                            }

                            volumeSeries.update(volumeBar);
                            return true;
                        } catch(e) {
                            console.error('updateVolume error:', e);
                            return false;
                        }
                    },

                    addIndicator: (name, color) => {
                        try {
                            const s = chart.addSeries(LineSeries, {
                                color,
                                lineWidth: 2,
                                title: name,
                                priceLineVisible: true,
                                lastValueVisible: true,
                                zOrder: -10,  // Render behind drawings
                            }, 0);
                            s.createPriceLine({ price: 0, color, lineWidth: 1, lineStyle: LineStyle.Dotted, axisLabelVisible: true, title: name });
                            overlaySeries[name] = s;
                            return true;
                        }
                        catch(e){ console.error(e); return false; }
                    },
                    removeIndicator: (name) => {
                        try { if (!overlaySeries[name]) return false; chart.removeSeries(overlaySeries[name]); delete overlaySeries[name]; return true; }
                        catch(e){ console.error(e); return false; }
                    },
                    setIndicatorData: (name, data) => { try { if (!overlaySeries[name]) return false; overlaySeries[name].setData(data); return true; } catch(e){ console.error(e); return false; } },
                    updateIndicator: (name, point) => { try { if (!overlaySeries[name]) return false; overlaySeries[name].update(point); return true; } catch(e){ console.error(e); return false; } },

                    createPanel: (panelId, displayName, type, color, min, max) => {
                        try {
                            if (panelMap[panelId] !== undefined) {
                                const existingPane = panelMap[panelId];
                                const existingIndex = typeof existingPane?.paneIndex === 'function' ? existingPane.paneIndex() : -1;
                                if (existingIndex >= 0) return true;
                                delete panelMap[panelId];
                            }
                            const paneApi = addPane(panelId);
                            const paneIndex = paneApi.paneIndex();
                            let series;
                            if (type === 'histogram') {
                                // Issue #VOLUME: Fix upside-down volume chart with proper scaleMargins
                                series = chart.addSeries(HistogramSeries, {
                                    base: 0,
                                    color,
                                    priceScaleId: 'right',
                                    priceFormat: { type: 'price', precision: 4, minMove: 0.0001 },
                                    title: displayName,
                                    // Critical: Volume should grow from bottom (0) upwards
                                    scaleMargins: { top: 0.1, bottom: 0.0 },
                                    autoscaleInfoProvider: () => ({
                                        priceRange: {
                                            minValue: 0,
                                            maxValue: null  // Auto-scale max
                                        }
                                    })
                                }, paneIndex);
                            } else {
                                const opts = { color, lineWidth: 2, title: displayName, priceScaleId: 'right' };
                                if (min !== null && max !== null) {
                                    opts.autoscaleInfoProvider = () => ({ priceRange: { minValue: min, maxValue: max } });
                                }
                                series = chart.addSeries(LineSeries, opts, paneIndex);
                            }
                            panelMainSeries[panelId] = series;
                            return true;
                        } catch(e){ console.error(e); return false; }
                    },

                    removePanel: (panelId) => { try { return removePane(panelId); } catch(e){ console.error(e); return false; } },

                    setPanelData: (panelId, data) => {
                        try {
                            const s = panelMainSeries[panelId];
                            if (!s) return false;
                            s.setData(data);

                            // Issue #47: Reset time tracker when panel data is set (timeframe/period change)
                            // This prevents "Cannot update oldest data" errors during live streaming
                            const timeKey = '_lastTime_' + panelId;
                            delete window[timeKey];

                            return true;
                        } catch(e){
                            console.error(e);
                            return false;
                        }
                    },
                    updatePanelData: (panelId, point) => {
                        try {
                            const s = panelMainSeries[panelId];
                            if (!s) return false;
                            // Track last update time to avoid "Cannot update oldest data" errors
                            const timeKey = '_lastTime_' + panelId;
                            if (window[timeKey] && point.time < window[timeKey]) {
                                // Skip older data silently
                                return false;
                            }
                            s.update(point);
                            window[timeKey] = point.time;
                            return true;
                        } catch(e){
                            // Silently ignore "Cannot update oldest data" errors
                            if (e.message && e.message.includes('oldest data')) return false;
                            console.error(e);
                            return false;
                        }
                    },

                    addPanelSeries: (panelId, seriesKey, type, color, data) => {
                        try {
                            let paneApi = panelMap[panelId];
                            if (paneApi && (typeof paneApi.paneIndex !== 'function' || paneApi.paneIndex() < 0)) {
                                delete panelMap[panelId];
                                paneApi = undefined;
                            }
                            paneApi = paneApi || addPane(panelId);
                            let paneIndex = paneApi.paneIndex();
                            if (paneIndex < 0) {
                                paneApi = addPane(panelId);
                                paneIndex = paneApi.paneIndex();
                            }
                            // Issue #VOLUME: Fix upside-down histograms with proper scaleMargins
                            const seriesOpts = type === 'histogram'
                                ? {
                                    base: 0,
                                    color,
                                    priceScaleId: 'right',
                                    priceFormat: { type: 'price', precision: 4, minMove: 0.0001 },
                                    title: seriesKey.toUpperCase(),
                                    scaleMargins: { top: 0.1, bottom: 0.0 },
                                    autoscaleInfoProvider: () => ({ priceRange: { minValue: 0, maxValue: null } })
                                }
                                : { color, lineWidth: 2, title: seriesKey.toUpperCase(), priceScaleId: 'right' };
                            const s = type === 'histogram'
                                ? chart.addSeries(HistogramSeries, seriesOpts, paneIndex)
                                : chart.addSeries(LineSeries, seriesOpts, paneIndex);
                            const key = panelId + '_' + seriesKey;
                            panelExtraSeries[key] = s;
                            if (data) s.setData(data);
                            return true;
                        } catch(e){ console.error(e); return false; }
                    },

                    setPanelSeriesData: (panelId, seriesKey, data) => { try { const s = panelExtraSeries[panelId + '_' + seriesKey]; if (!s) return false; s.setData(data); return true; } catch(e){ console.error(e); return false; } },
                    updatePanelSeriesData: (panelId, seriesKey, point) => { try { const s = panelExtraSeries[panelId + '_' + seriesKey]; if (!s) return false; s.update(point); return true; } catch(e){ console.error(e); return false; } },

                    addPanelPriceLine: (panelId, price, color, lineStyle, title) => {
                        try {
                            const s = panelMainSeries[panelId];
                            if (!s) return false;
                            let style = LineStyle.Dashed;
                            if (lineStyle === 'solid') style = LineStyle.Solid; else if (lineStyle === 'dotted') style = LineStyle.Dotted;
                            s.createPriceLine({ price, color, lineWidth: 1, lineStyle: style, axisLabelVisible: true, title: title || '' });
                            return true;
                        } catch(e){ console.error(e); return false; }
                    },

                    fitContent: () => {
                        try {
                            rememberViewState();
                            if (!suppressFitContent) {
                                refitPriceScale();
                            } else {
                                console.log('fitContent: suppressed');
                            }
                        } catch(e){ console.error(e); }
                    },
                    resetPriceScale: () => { try { refitPriceScale(); } catch(e){ console.error(e); } },
                    extendDrawingArea: () => { try { extendVisibleRange(); return true; } catch(e){ console.error(e); return false; } },

                    addTradeMarkers: (markers) => {
                        try {
                            if (!Array.isArray(markers)) return false;
                            // Use v5 createSeriesMarkers API
                            if (seriesMarkers) {
                                // Update existing markers primitive
                                seriesMarkers.setMarkers(markers);
                            } else if (markers.length > 0) {
                                // Create new markers primitive
                                seriesMarkers = createSeriesMarkers(priceSeries, markers);
                            }
                            console.log('Added ' + markers.length + ' trade markers');
                            return true;
                        } catch(e){ console.error('addTradeMarkers error:', e); return false; }
                    },

                    clearMarkers: () => {
                        try {
                            if (seriesMarkers) {
                                seriesMarkers.setMarkers([]);
                            }
                            console.log('Cleared markers');
                            return true;
                        }
                        catch(e){ console.error('clearMarkers error:', e); return false; }
                    },

                    updateBar: (bar) => {
                        try {
                            if (!bar || typeof bar !== 'object') return false;
                            // Track last update time to avoid "Cannot update oldest data" errors
                            if (window._lastBarTime && bar.time < window._lastBarTime) {
                                return false;
                            }
                            priceSeries.update(bar);
                            window._lastBarTime = bar.time;
                            return true;
                        } catch(e){
                            if (e.message && e.message.includes('oldest data')) return false;
                            console.error(e);
                            return false;
                        }
                    },

                    getVisibleRange: () => {
                        try { return chart.timeScale().getVisibleLogicalRange(); }
                        catch(e) { console.error(e); return null; }
                    },

                    setVisibleRange: (range) => {
                        try {
                            if (!range) return false;
                            chart.timeScale().setVisibleLogicalRange(range);
                            return true;
                        } catch(e) { console.error(e); return false; }
                    },

                    getPaneLayout: () => {
                        try {
                            const layout = {};
                            const allPanes = chart.panes();
                            const factors = {};
                            if (allPanes.length > 0 && typeof allPanes[0].getStretchFactor === 'function') {
                                factors['price'] = allPanes[0].getStretchFactor();
                            }
                            for (const [id, paneApi] of Object.entries(panelMap)) {
                                if (paneApi && typeof paneApi.getStretchFactor === 'function') {
                                    factors[id] = paneApi.getStretchFactor();
                                }
                            }
                            let total = 0;
                            for (const factor of Object.values(factors)) { total += factor; }
                            if (total > 0) {
                                for (const [id, factor] of Object.entries(factors)) {
                                    layout[id] = Math.round((factor / total) * 100);
                                }
                            }
                            return layout;
                        } catch(e) { console.error(e); return {}; }
                    },

                    resizeToContainer: () => {
                        try {
                            const container = document.getElementById('chart-container');
                            if (!container || !chart) return false;
                            const rect = container.getBoundingClientRect();
                            const width = Math.max(50, Math.floor(rect.width));
                            const height = Math.max(50, Math.floor(rect.height));
                            chart.resize(width, height);
                            return { width, height };
                        } catch(e) { console.error(e); return false; }
                    },

                    setPaneLayout: (layout) => {
                        try {
                            if (!layout || Object.keys(layout).length === 0) return false;
                            let restored = 0;
                            const allPanes = chart.panes();
                            if (layout['price'] !== undefined && allPanes.length > 0) {
                                const pricePane = allPanes[0];
                                if (typeof pricePane.setStretchFactor === 'function') {
                                    pricePane.setStretchFactor(layout['price']);
                                    restored++;
                                }
                            }
                            for (const [id, percentValue] of Object.entries(layout)) {
                                if (id === 'price') continue;
                                const paneApi = panelMap[id];
                                if (paneApi && typeof paneApi.setStretchFactor === 'function') {
                                    paneApi.setStretchFactor(percentValue);
                                    restored++;
                                }
                            }
                            setTimeout(() => {
                                try {
                                    chart.applyOptions({});
                                    const container = document.getElementById('chart-container');
                                    if (container) {
                                        chart.resize(container.clientWidth, container.clientHeight);
                                    }
                                    // REMOVED: fitContent() was resetting zoom after pane layout restoration
                                    // The visible range should be preserved, only pane heights change
                                } catch(e) {}
                            }, 100);
                            return restored > 0;
                        } catch(e) { console.error(e); return false; }
                    },

                    getChartState: () => {
                        try {
                            const visibleRange = chart.timeScale().getVisibleLogicalRange();
                            const paneLayout = window.chartAPI.getPaneLayout();
                            return {
                                version: '1.0.0',
                                timestamp: Date.now(),
                                visibleRange: visibleRange,
                                paneLayout: paneLayout,
                                activeSeries: {
                                    overlays: Object.keys(overlaySeries),
                                    panels: Object.keys(panelMap)
                                },
                                drawings: window.chartAPI.getDrawings ? window.chartAPI.getDrawings() : [],
                                chartOptions: { autoSize: true }
                            };
                        } catch(e) { console.error(e); return {}; }
                    },

                    setChartState: (state) => {
                        try {
                            if (!state || !state.version) return false;
                            let restored = 0;
                            if (state.visibleRange) {
                                try { window.chartAPI.setVisibleRange(state.visibleRange); restored++; }
                                catch(e) {}
                            }
                            if (state.paneLayout) {
                                setTimeout(() => {
                                    try { window.chartAPI.setPaneLayout(state.paneLayout); }
                                    catch(e) {}
                                }, 500);
                                restored++;
                            }
                            if (state.drawings && Array.isArray(state.drawings) && state.drawings.length) {
                                try { clearAllDrawings(); } catch(e){}
                                state.drawings.forEach(d => {
                                    try {
                                        if (d.type === 'hline') {
                                            window.chartAPI.addHorizontalLine(d.price, d.color || '#26a69a', d.label || '', d.lineStyle || 'solid', d.id || null);
                                        } else if (d.type === 'rect-range') {
                                            window.chartAPI.addRectRange(d.priceLow, d.priceHigh, d.color || 'rgba(13,110,253,0.18)', d.label || '');
                                        } else if (d.type === 'percent-rect') {
                                            if (d.p1 && d.p2) window.chartAPI.addPercentRect(d.p1, d.p2, d.id || null);
                                        } else if (d.type === 'fibonacci') {
                                            if (d.p1 && d.p2) window.chartAPI.addFibonacci(d.p1, d.p2, d.id || null);
                                        } else if (d.type === 'trendline' || d.type === 'ray') {
                                            if (d.p1 && d.p2) window.chartAPI.addTrendLine(d.p1, d.p2, d.color || '#ffeb3b');
                                        }
                                    } catch(err) { console.warn('restore drawing failed', err); }
                                });
                            }
                            return restored > 0;
                        } catch(e) { console.error(e); return false; }
                    },

                    rememberViewState: () => { rememberViewState(); return true; },

                    restoreLastView: () => {
                        try {
                            if (!lastViewState || !lastViewState.visibleRange) return false;
                            window.chartAPI.setPaneLayout(lastViewState.paneLayout || {});
                            window.chartAPI.setVisibleRange(lastViewState.visibleRange);
                            return true;
                        } catch(e) { console.error(e); return false; }
                    },

                    normalizePaneHeights: () => {
                        normalizePaneHeights();
                    },

                    clear: () => {
                        try {
                            priceSeries.setData([]);
                            // Clear markers using v5 API
                            if (seriesMarkers) {
                                seriesMarkers.destroy();
                                seriesMarkers = null;
                            }
                            Object.values(overlaySeries).forEach(s => chart.removeSeries(s));
                            Object.keys(overlaySeries).forEach(k => delete overlaySeries[k]);
                            Object.keys(panelMap).forEach(pid => removePane(pid));
                        } catch(e){ console.error(e); }
                    }
                };

                // ZONE_PRIMITIVE_JS_PLACEHOLDER

                // ==================== DRAWING TOOLS ====================

                // Drawing state
                let currentTool = 'pointer';
                let drawingPoints = [];
                let previewPrimitive = null;
                const drawings = []; // All drawn primitives
                let selectedDrawing = null;
                let rectStage = null; // first price click for rect-range

                function pickRectColor(currentColor = 'rgba(13,110,253,0.18)') {
                    // Use Python QColorDialog via bridge (same as evaluation table)
                    return new Promise(resolve => {
                        if (window.chartBridge && typeof window.chartBridge.pickColor === 'function') {
                            try {
                                const chosenColor = window.chartBridge.pickColor(currentColor);
                                resolve(chosenColor || currentColor);
                            } catch (e) {
                                console.error('Color dialog failed:', e);
                                resolve(currentColor);
                            }
                        } else {
                            console.warn('chartBridge.pickColor not available, using default color');
                            resolve(currentColor);
                        }
                    });
                }

                // Drawing primitive classes
                class HorizontalLinePrimitive {
                    constructor(price, color, id, label = '', lineStyle = 'solid') {
                        this.price = price;
                        this.color = color;
                        this.id = id;
                        this.label = label;
                        this.lineStyle = lineStyle;
                        this.type = 'hline';
                        this._paneViews = [new HorizontalLinePaneView(this)];
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class HorizontalLinePaneView {
                    constructor(source) { this._source = source; this._y = null; }
                    update() { this._y = priceSeries.priceToCoordinate(this._source.price); }
                    renderer() { return new HorizontalLineRenderer(this._y, this._source.color, this._source.label, this._source.lineStyle); }
                }

                class HorizontalLineRenderer {
                    constructor(y, color, label = '', lineStyle = 'solid') {
                        this._y = y;
                        this._color = color;
                        this._label = label;
                        this._lineStyle = lineStyle;
                    }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._y === null) return;
                            const ctx = scope.context;
                            const yScaled = Math.round(this._y * scope.verticalPixelRatio);

                            // Draw line
                            ctx.strokeStyle = this._color;
                            ctx.lineWidth = 2;
                            if (this._lineStyle === 'dashed') {
                                ctx.setLineDash([8, 4]);
                            } else if (this._lineStyle === 'dotted') {
                                ctx.setLineDash([2, 2]);
                            } else {
                                ctx.setLineDash([]);
                            }
                            ctx.beginPath();
                            ctx.moveTo(0, yScaled);
                            ctx.lineTo(scope.bitmapSize.width, yScaled);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            // Draw label if provided (Issue #24: label on left side)
                            if (this._label) {
                                const fontSize = 11 * scope.verticalPixelRatio;
                                ctx.font = `bold ${fontSize}px Arial`;
                                const textWidth = ctx.measureText(this._label).width;
                                const padding = 4 * scope.verticalPixelRatio;
                                const labelX = padding * 2;  // Left side of chart
                                const labelY = yScaled - padding;

                                // Background
                                ctx.fillStyle = this._color;
                                ctx.fillRect(labelX - padding, labelY - fontSize, textWidth + padding * 2, fontSize + padding);

                                // Text
                                ctx.fillStyle = '#ffffff';
                                ctx.fillText(this._label, labelX, labelY - padding/2);
                            }
                        });
                    }
                }

                class RectRangePrimitive {
                    constructor(pLow, pHigh, color, label, id) {
                        this.pLow = Math.min(pLow, pHigh);
                        this.pHigh = Math.max(pLow, pHigh);
                        this.color = color;
                        this.label = label || '';
                        this.id = id || genId();
                        this.type = 'rect-range';
                        this._paneViews = [new RectRangePaneView(this)];
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class RectRangePaneView {
                    constructor(source) { this._source = source; this._y1 = null; this._y2 = null; }
                    update() {
                        const low = this._source.pLow;
                        const high = this._source.pHigh;
                        this._y1 = priceSeries.priceToCoordinate(high);
                        this._y2 = priceSeries.priceToCoordinate(low);
                    }
                    renderer() { return new RectRangeRenderer(this._y1, this._y2, this._source.color, this._source.label); }
                }

                class RectRangeRenderer {
                    constructor(y1, y2, color, label) {
                        this._y1 = y1;
                        this._y2 = y2;
                        this._color = color;
                        this._label = label;
                    }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._y1 == null || this._y2 == null) return;
                            const ctx = scope.context;
                            const top = Math.min(this._y1, this._y2) * scope.verticalPixelRatio;
                            const bottom = Math.max(this._y1, this._y2) * scope.verticalPixelRatio;
                            const height = bottom - top;

                            // fill
                            ctx.fillStyle = this._color || 'rgba(13,110,253,0.18)';
                            ctx.fillRect(0, top, scope.bitmapSize.width, height);
                            // border
                            ctx.strokeStyle = this._color || '#0d6efd';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(0, top, scope.bitmapSize.width, height);

                            if (this._label) {
                                ctx.fillStyle = '#eaeaea';
                                ctx.font = `bold ${12 * scope.verticalPixelRatio}px Segoe UI`;
                                ctx.fillText(this._label, 8 * scope.horizontalPixelRatio, top + 16 * scope.verticalPixelRatio);
                            }
                        });
                    }
                }

                class TrendLinePrimitive {
                    constructor(p1, p2, color, id) {
                        this.p1 = p1; this.p2 = p2; this.color = color; this.id = id;
                        this.type = 'trendline';
                        this._paneViews = [new TrendLinePaneView(this)];
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class TrendLinePaneView {
                    constructor(source) { this._source = source; this._p1 = {x:null,y:null}; this._p2 = {x:null,y:null}; }
                    update() {
                        const ts = chart.timeScale();
                        this._p1 = { x: ts.timeToCoordinate(this._source.p1.time), y: priceSeries.priceToCoordinate(this._source.p1.price) };
                        this._p2 = { x: ts.timeToCoordinate(this._source.p2.time), y: priceSeries.priceToCoordinate(this._source.p2.price) };
                    }
                    renderer() { return new TrendLineRenderer(this._p1, this._p2, this._source.color); }
                }

                class TrendLineRenderer {
                    constructor(p1, p2, color) { this._p1 = p1; this._p2 = p2; this._color = color; }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._p1.x === null || this._p1.y === null || this._p2.x === null || this._p2.y === null) return;
                            const ctx = scope.context;
                            const x1 = Math.round(this._p1.x * scope.horizontalPixelRatio);
                            const y1 = Math.round(this._p1.y * scope.verticalPixelRatio);
                            const x2 = Math.round(this._p2.x * scope.horizontalPixelRatio);
                            const y2 = Math.round(this._p2.y * scope.verticalPixelRatio);
                            ctx.strokeStyle = this._color;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                            // Draw endpoints
                            ctx.fillStyle = this._color;
                            ctx.beginPath(); ctx.arc(x1, y1, 4, 0, 2*Math.PI); ctx.fill();
                            ctx.beginPath(); ctx.arc(x2, y2, 4, 0, 2*Math.PI); ctx.fill();
                        });
                    }
                }

                class RayPrimitive {
                    constructor(p1, p2, color, id) {
                        this.p1 = p1; this.p2 = p2; this.color = color; this.id = id;
                        this.type = 'ray';
                        this._paneViews = [new RayPaneView(this)];
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class RayPaneView {
                    constructor(source) { this._source = source; this._p1 = {x:null,y:null}; this._p2 = {x:null,y:null}; }
                    update() {
                        const ts = chart.timeScale();
                        this._p1 = { x: ts.timeToCoordinate(this._source.p1.time), y: priceSeries.priceToCoordinate(this._source.p1.price) };
                        this._p2 = { x: ts.timeToCoordinate(this._source.p2.time), y: priceSeries.priceToCoordinate(this._source.p2.price) };
                    }
                    renderer() { return new RayRenderer(this._p1, this._p2, this._source.color); }
                }

                class RayRenderer {
                    constructor(p1, p2, color) { this._p1 = p1; this._p2 = p2; this._color = color; }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._p1.x === null || this._p1.y === null || this._p2.x === null || this._p2.y === null) return;
                            const ctx = scope.context;
                            const x1 = Math.round(this._p1.x * scope.horizontalPixelRatio);
                            const y1 = Math.round(this._p1.y * scope.verticalPixelRatio);
                            const x2 = Math.round(this._p2.x * scope.horizontalPixelRatio);
                            const y2 = Math.round(this._p2.y * scope.verticalPixelRatio);
                            // Extend line to edge of chart
                            const dx = x2 - x1; const dy = y2 - y1;
                            const len = Math.sqrt(dx*dx + dy*dy);
                            if (len === 0) return;
                            const extendX = x1 + (dx/len) * scope.bitmapSize.width * 2;
                            const extendY = y1 + (dy/len) * scope.bitmapSize.width * 2;
                            ctx.strokeStyle = this._color;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(extendX, extendY);
                            ctx.stroke();
                            // Draw start point
                            ctx.fillStyle = this._color;
                            ctx.beginPath(); ctx.arc(x1, y1, 5, 0, 2*Math.PI); ctx.fill();
                        });
                    }
                }

                // ==================== PERCENT RECTANGLE TOOL ====================
                class PercentRectPrimitive {
                    constructor(p1, p2, id) {
                        this.p1 = p1;  // First point: reference price (100%)
                        this.p2 = p2;  // Second point: comparison price
                        this.id = id;
                        this.type = 'percent-rect';
                        this.updatePercent();
                        this._paneViews = [new PercentRectPaneView(this)];
                    }
                    updatePercent() {
                        // Calculate percent difference based on current p1 and p2
                        const denom = this.p1.price || 0;
                        if (!denom || !isFinite(denom)) {
                            this.percentDiff = 0;
                        } else {
                            this.percentDiff = ((this.p2.price - this.p1.price) / denom) * 100;
                        }
                        // Color: green for positive, red for negative
                        this.color = this.percentDiff >= 0 ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)';
                        this.borderColor = this.percentDiff >= 0 ? '#26a69a' : '#ef5350';
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class PercentRectPaneView {
                    constructor(source) {
                        this._source = source;
                        this._p1 = {x:null,y:null};
                        this._p2 = {x:null,y:null};
                    }
                    update() {
                        const ts = chart.timeScale();
                        this._p1 = {
                            x: ts.timeToCoordinate(this._source.p1.time),
                            y: priceSeries.priceToCoordinate(this._source.p1.price)
                        };
                        this._p2 = {
                            x: ts.timeToCoordinate(this._source.p2.time),
                            y: priceSeries.priceToCoordinate(this._source.p2.price)
                        };
                    }
                    renderer() {
                        return new PercentRectRenderer(
                            this._p1, this._p2,
                            this._source.color, this._source.borderColor,
                            this._source.percentDiff, this._source.p1.price, this._source.p2.price
                        );
                    }
                }

                class PercentRectRenderer {
                    constructor(p1, p2, fillColor, borderColor, percentDiff, price1, price2) {
                        this._p1 = p1;
                        this._p2 = p2;
                        this._fillColor = fillColor;
                        this._borderColor = borderColor;
                        this._percentDiff = percentDiff;
                        this._price1 = price1;
                        this._price2 = price2;
                    }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._p1.x === null || this._p1.y === null ||
                                this._p2.x === null || this._p2.y === null) return;
                            const ctx = scope.context;
                            const x1 = Math.round(this._p1.x * scope.horizontalPixelRatio);
                            const y1 = Math.round(this._p1.y * scope.verticalPixelRatio);
                            const x2 = Math.round(this._p2.x * scope.horizontalPixelRatio);
                            const y2 = Math.round(this._p2.y * scope.verticalPixelRatio);

                            // Draw filled rectangle
                            ctx.fillStyle = this._fillColor;
                            ctx.fillRect(Math.min(x1, x2), Math.min(y1, y2),
                                        Math.abs(x2 - x1), Math.abs(y2 - y1));

                            // Draw border
                            ctx.strokeStyle = this._borderColor;
                            ctx.lineWidth = 2;
                            ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2),
                                          Math.abs(x2 - x1), Math.abs(y2 - y1));

                            // Draw percentage label in the center
                            const centerX = (x1 + x2) / 2;
                            const centerY = (y1 + y2) / 2;
                            const sign = this._percentDiff >= 0 ? '+' : '';
                            const labelText = `${sign}${this._percentDiff.toFixed(2)}%`;

                            const fontSize = 14 * scope.verticalPixelRatio;
                            ctx.font = `bold ${fontSize}px Arial`;
                            const textWidth = ctx.measureText(labelText).width;
                            const padding = 6 * scope.verticalPixelRatio;

                            // Background for label
                            ctx.fillStyle = this._borderColor;
                            ctx.fillRect(centerX - textWidth/2 - padding, centerY - fontSize/2 - padding/2,
                                        textWidth + padding*2, fontSize + padding);

                            // Label text
                            ctx.fillStyle = '#ffffff';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(labelText, centerX, centerY);

                            // Draw price labels at corners
                            const smallFontSize = 10 * scope.verticalPixelRatio;
                            ctx.font = `${smallFontSize}px Arial`;
                            ctx.fillStyle = this._borderColor;

                            // Start price (100%)
                            const price1Text = `${this._price1.toFixed(2)} (100%)`;
                            ctx.textAlign = 'left';
                            ctx.fillText(price1Text, Math.min(x1, x2) + 4, y1 + (y1 < y2 ? smallFontSize + 2 : -4));

                            // End price
                            const price2Text = `${this._price2.toFixed(2)}`;
                            ctx.fillText(price2Text, Math.min(x1, x2) + 4, y2 + (y2 < y1 ? smallFontSize + 2 : -4));

                            // Draw corner points
                            ctx.fillStyle = this._borderColor;
                            ctx.beginPath(); ctx.arc(x1, y1, 4, 0, 2*Math.PI); ctx.fill();
                            ctx.beginPath(); ctx.arc(x2, y2, 4, 0, 2*Math.PI); ctx.fill();
                        });
                    }
                }

                // ==================== FIBONACCI RETRACEMENT TOOL ====================
                class FibonacciRetracementPrimitive {
                    constructor(p1, p2, id) {
                        this.p1 = p1;
                        this.p2 = p2;
                        this.id = id;
                        this.type = 'fibonacci';
                        this.levels = this.calculateLevels();
                        this._paneViews = [new FibonacciRetracementPaneView(this)];
                    }
                    calculateLevels() {
                        const fibs = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
                        const levelColors = {
                            0: '#9e9e9e',
                            0.236: '#2196f3',   // blue
                            0.382: '#ab47bc',   // purple
                            0.5: '#fbc02d',     // yellow
                            0.618: '#26a69a',   // teal
                            0.786: '#ff7043',   // orange
                            1: '#9e9e9e'
                        };
                        const delta = this.p2.price - this.p1.price;
                        return fibs.map(l => ({
                            level: l,
                            price: this.p1.price + delta * l,
                            color: levelColors[l] || '#8bc34a'
                        }));
                    }
                    updateAllViews() { this._paneViews.forEach(v => v.update()); }
                    paneViews() { return this._paneViews; }
                }

                class FibonacciRetracementPaneView {
                    constructor(source) {
                        this._source = source;
                        this._p1 = { x: null, y: null };
                        this._p2 = { x: null, y: null };
                    }
                    update() {
                        const ts = chart.timeScale();
                        this._p1 = { x: ts.timeToCoordinate(this._source.p1.time), y: priceSeries.priceToCoordinate(this._source.p1.price) };
                        this._p2 = { x: ts.timeToCoordinate(this._source.p2.time), y: priceSeries.priceToCoordinate(this._source.p2.price) };
                    }
                    renderer() {
                        return new FibonacciRetracementRenderer(this._p1, this._p2, this._source.levels);
                    }
                }

                class FibonacciRetracementRenderer {
                    constructor(p1, p2, levels) {
                        this._p1 = p1;
                        this._p2 = p2;
                        this._levels = levels;
                    }
                    draw(target) {
                        target.useBitmapCoordinateSpace(scope => {
                            if (this._p1.x === null || this._p2.x === null || this._p1.y === null || this._p2.y === null) return;
                            const ctx = scope.context;
                            const x1 = Math.round(this._p1.x * scope.horizontalPixelRatio);
                            const x2 = Math.round(this._p2.x * scope.horizontalPixelRatio);
                            const y1 = Math.round(this._p1.y * scope.verticalPixelRatio);
                            const y2 = Math.round(this._p2.y * scope.verticalPixelRatio);
                            const minX = Math.min(x1, x2);
                            const maxX = Math.max(x1, x2);
                            const minY = Math.min(y1, y2);
                            const maxY = Math.max(y1, y2);

                            // Draw bands and lines
                            ctx.lineWidth = 1;
                            ctx.font = `${12 * scope.verticalPixelRatio}px Arial`;
                            const toRgba = (hex, alpha) => {
                                if (!hex || !hex.startsWith('#') || (hex.length !== 7 && hex.length !== 9)) return `rgba(139,195,74,${alpha})`;
                                const r = parseInt(hex.slice(1,3),16);
                                const g = parseInt(hex.slice(3,5),16);
                                const b = parseInt(hex.slice(5,7),16);
                                return `rgba(${r},${g},${b},${alpha})`;
                            };

                            this._levels.forEach((lvl, idx) => {
                                const y = y1 + (y2 - y1) * lvl.level;
                                const yPix = Math.round(y);

                                // Optional fill between this and next level for better visibility
                                if (idx < this._levels.length - 1) {
                                    const nextY = y1 + (y2 - y1) * this._levels[idx + 1].level;
                                    ctx.fillStyle = toRgba(lvl.color, 0.08);
                                    ctx.fillRect(minX, Math.min(yPix, nextY), maxX - minX, Math.abs(nextY - yPix));
                                }

                                ctx.strokeStyle = lvl.color || '#8bc34a';
                                ctx.beginPath();
                                ctx.moveTo(minX, yPix);
                                ctx.lineTo(maxX, yPix);
                                ctx.stroke();

                                const label = `${(lvl.level * 100).toFixed(1)}%  ${lvl.price.toFixed(2)}`;
                                ctx.fillStyle = lvl.color || '#8bc34a';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(label, minX + 4, yPix);
                            });

                            // Edge handles
                            ctx.fillStyle = '#8bc34a';
                            ctx.beginPath(); ctx.arc(x1, y1, 4, 0, 2 * Math.PI); ctx.fill();
                            ctx.beginPath(); ctx.arc(x2, y2, 4, 0, 2 * Math.PI); ctx.fill();
                            // Border box
                            ctx.strokeStyle = 'rgba(139,195,74,0.5)';
                            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                        });
                    }
                }

                // ==================== GENERIC UTILITIES ====================
                let drawingIdCounter = 0;
                const genId = () => 'drawing_' + (++drawingIdCounter);

                // Crosshair mode management
                let savedCrosshairMode = CrosshairMode.Normal;
                function disableCrosshairMagnet() {
                    savedCrosshairMode = CrosshairMode.Normal;
                    chart.applyOptions({ crosshair: { mode: CrosshairMode.Hidden } });
                }
                function restoreCrosshairMode() {
                    chart.applyOptions({ crosshair: { mode: savedCrosshairMode } });
                }

                // Drag state for drawings
                let isDragging = false;
                let dragTarget = null;      // { drawing, handle: 'line'|'p1'|'p2' }
                let dragStartY = 0;
                let dragStartX = 0;

                // Y-Pan state for price axis scrolling
                let isYPanning = false;
                let yPanStartY = 0;
                let yPanStartRange = null;

                // Tool selection
                function selectTool(toolId) {
                    // Restore crosshair when switching away from drawing tools
                    if (currentTool !== 'pointer' && toolId === 'pointer') {
                        restoreCrosshairMode();
                    }
                    // Disable crosshair for drawing tools
                    if (toolId !== 'pointer' && toolId !== 'delete') {
                        disableCrosshairMagnet();
                    }
                    currentTool = toolId;
                    drawingPoints = [];
                    removePreview();
                    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                    const btn = document.getElementById('tool-' + toolId);
                    if (btn) btn.classList.add('active');
                    container.style.cursor = toolId === 'pointer' ? 'default' : 'crosshair';
                    rectStage = null;
                }

                function removePreview() {
                    if (previewPrimitive) {
                        priceSeries.detachPrimitive(previewPrimitive);
                        previewPrimitive = null;
                    }
                }

                function removeDrawing(drawing) {
                    priceSeries.detachPrimitive(drawing);
                    const idx = drawings.indexOf(drawing);
                    if (idx > -1) drawings.splice(idx, 1);
                }

                function clearAllDrawings() {
                    drawings.forEach(d => priceSeries.detachPrimitive(d));
                    drawings.length = 0;
                    selectedDrawing = null;
                }

                // Hit detection for drag handles
                function findDragTarget(x, y) {
                    const threshold = 10;
                    for (const d of drawings) {
                        if (d.type === 'hline') {
                            const lineY = priceSeries.priceToCoordinate(d.price);
                            if (lineY !== null && Math.abs(y - lineY) < threshold) {
                                return { drawing: d, handle: 'line' };
                            }
                        } else if (d.type === 'trendline' || d.type === 'ray') {
                            const ts = chart.timeScale();
                            const x1 = ts.timeToCoordinate(d.p1.time);
                            const y1 = priceSeries.priceToCoordinate(d.p1.price);
                            const x2 = ts.timeToCoordinate(d.p2.time);
                            const y2 = priceSeries.priceToCoordinate(d.p2.price);
                            if (x1 !== null && y1 !== null) {
                                // Check P1 handle
                                if (Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1)) < threshold) {
                                    return { drawing: d, handle: 'p1' };
                                }
                            }
                            if (x2 !== null && y2 !== null) {
                                // Check P2 handle
                                if (Math.sqrt((x-x2)*(x-x2) + (y-y2)*(y-y2)) < threshold) {
                                    return { drawing: d, handle: 'p2' };
                                }
                            }
                            // Check line itself for whole-line drag
                            if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                const dist = pointToSegmentDist(x, y, x1, y1, x2, y2);
                                if (dist < threshold) {
                                    return { drawing: d, handle: 'line' };
                                }
                            }
                        } else if (d.type === 'percent-rect') {
                            // Hit detection for percent rectangle corners
                            const ts = chart.timeScale();
                            const x1 = ts.timeToCoordinate(d.p1.time);
                            const y1 = priceSeries.priceToCoordinate(d.p1.price);
                            const x2 = ts.timeToCoordinate(d.p2.time);
                            const y2 = priceSeries.priceToCoordinate(d.p2.price);
                            if (x1 !== null && y1 !== null) {
                                // Check P1 handle (top-left or start point)
                                if (Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1)) < threshold) {
                                    return { drawing: d, handle: 'p1' };
                                }
                            }
                            if (x2 !== null && y2 !== null) {
                                // Check P2 handle (bottom-right or end point)
                                if (Math.sqrt((x-x2)*(x-x2) + (y-y2)*(y-y2)) < threshold) {
                                    return { drawing: d, handle: 'p2' };
                                }
                            }
                            // Check if inside rectangle for whole-rect drag
                            if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                const minX = Math.min(x1, x2);
                                const maxX = Math.max(x1, x2);
                                const minY = Math.min(y1, y2);
                                const maxY = Math.max(y1, y2);
                                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                                    return { drawing: d, handle: 'rect' };
                                }
                            }
                        } else if (d.type === 'fibonacci') {
                            // Hit detection for fibonacci retracement
                            const ts = chart.timeScale();
                            const x1 = ts.timeToCoordinate(d.p1.time);
                            const y1 = priceSeries.priceToCoordinate(d.p1.price);
                            const x2 = ts.timeToCoordinate(d.p2.time);
                            const y2 = priceSeries.priceToCoordinate(d.p2.price);
                            if (x1 !== null && y1 !== null) {
                                // Check P1 handle (start point)
                                if (Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1)) < threshold) {
                                    return { drawing: d, handle: 'p1' };
                                }
                            }
                            if (x2 !== null && y2 !== null) {
                                // Check P2 handle (end point)
                                if (Math.sqrt((x-x2)*(x-x2) + (y-y2)*(y-y2)) < threshold) {
                                    return { drawing: d, handle: 'p2' };
                                }
                            }
                            // Check if inside fibonacci zone for whole-fib drag
                            if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                const minX = Math.min(x1, x2);
                                const maxX = Math.max(x1, x2);
                                const minY = Math.min(y1, y2);
                                const maxY = Math.max(y1, y2);
                                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                                    return { drawing: d, handle: 'rect' };
                                }
                            }
                        } else if (d.type === 'rect-range') {
                            const y1 = priceSeries.priceToCoordinate(d.pLow);
                            const y2 = priceSeries.priceToCoordinate(d.pHigh);
                            if (y1 !== null && y2 !== null) {
                                const minY = Math.min(y1, y2);
                                const maxY = Math.max(y1, y2);
                                if (Math.abs(y - minY) < threshold) return { drawing: d, handle: 'top' };
                                if (Math.abs(y - maxY) < threshold) return { drawing: d, handle: 'bottom' };
                                if (y >= minY && y <= maxY) return { drawing: d, handle: 'body' };
                            }
                        }
                    }
                    return null;
                }

                // Mouse event handlers for dragging
                container.addEventListener('mousedown', e => {
                    if (currentTool !== 'pointer') return;
                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const target = findDragTarget(x, y);
                    if (target) {
                        // Drawing drag
                        isDragging = true;
                        dragTarget = target;
                        dragStartX = x;
                        dragStartY = y;
                        container.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();
                    } else if (e.button === 0) {
                        // Left click without drawing target - enable Y-panning
                        // Issue #8 Fix: Allow Y-panning even during streaming
                        // User should be able to manually scroll the chart vertically
                        // First disable autoScale to allow manual Y control
                        try {
                            // Issue #8: Disable autoScale when user starts panning
                            // This allows viewing stop-loss lines and other elements
                            rightScale.applyOptions({ autoScale: false });
                            window._userDisabledAutoScale = true;  // Track that user manually disabled
                            // Try to get visible price range (may not exist in all versions)
                            const range = typeof rightScale.getVisiblePriceRange === 'function'
                                ? rightScale.getVisiblePriceRange()
                                : null;
                            if (range) {
                                isYPanning = true;
                                yPanStartY = y;
                                yPanStartRange = { from: range.from, to: range.to };
                            }
                        } catch (err) {
                            console.warn('Y-panning not available:', err.message);
                        }
                    }
                }, true);

                container.addEventListener('mousemove', e => {
                    // Handle Y-panning (when no drawing is being dragged)
                    if (isYPanning && yPanStartRange) {
                        const rect = container.getBoundingClientRect();
                        const y = e.clientY - rect.top;
                        const dy = y - yPanStartY;

                        // Convert pixel movement to price movement
                        const chartHeight = rect.height;
                        const priceRange = yPanStartRange.to - yPanStartRange.from;
                        const pricePerPixel = priceRange / chartHeight;
                        const priceDelta = dy * pricePerPixel;

                        // Apply new range (move in same direction as mouse)
                        const newFrom = yPanStartRange.from + priceDelta;
                        const newTo = yPanStartRange.to + priceDelta;
                        try {
                            if (typeof rightScale.setVisiblePriceRange === 'function') {
                                rightScale.setVisiblePriceRange({ from: newFrom, to: newTo });
                            }
                        } catch (err) {
                            console.warn('setVisiblePriceRange failed:', err.message);
                        }
                        return;
                    }

                    if (!isDragging || !dragTarget) {
                        // Update cursor on hover
                        if (currentTool === 'pointer') {
                            const rect = container.getBoundingClientRect();
                            const x = e.clientX - rect.left;
                            const y = e.clientY - rect.top;
                            const target = findDragTarget(x, y);
                            if (target) {
                                if (target.handle === 'p1' || target.handle === 'p2') {
                                    container.style.cursor = 'move';
                                } else if (target.drawing.type === 'hline') {
                                    container.style.cursor = 'ns-resize';
                                } else if (target.drawing.type === 'percent-rect' && target.handle === 'rect') {
                                    container.style.cursor = 'grab';
                                } else if (target.drawing.type === 'rect-range') {
                                    if (target.handle === 'top' || target.handle === 'bottom') {
                                        container.style.cursor = 'ns-resize';
                                    } else if (target.handle === 'body') {
                                        container.style.cursor = 'grab';
                                    }
                                } else {
                                    container.style.cursor = 'grab';
                                }
                            } else {
                                container.style.cursor = 'default';
                            }
                        }
                        return;
                    }
                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const d = dragTarget.drawing;
                    const ts = chart.timeScale();

                    if (d.type === 'hline') {
                        // Move horizontal line in Y only
                        const newPrice = priceSeries.coordinateToPrice(y);
                        if (newPrice !== null) {
                            d.price = newPrice;
                            d.updateAllViews();
                            chart.timeScale().applyOptions({}); // Force redraw
                        }
                    } else if (d.type === 'trendline' || d.type === 'ray') {
                        const newPrice = priceSeries.coordinateToPrice(y);
                        const newTime = ts.coordinateToTime(x);
                        if (newPrice !== null && newTime !== null) {
                            if (dragTarget.handle === 'p1') {
                                d.p1 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'p2') {
                                d.p2 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'line') {
                                // Move whole line
                                const dx = x - dragStartX;
                                const dy = y - dragStartY;
                                const x1 = ts.timeToCoordinate(d.p1.time);
                                const y1 = priceSeries.priceToCoordinate(d.p1.price);
                                const x2 = ts.timeToCoordinate(d.p2.time);
                                const y2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                    const newTime1 = ts.coordinateToTime(x1 + dx);
                                    const newPrice1 = priceSeries.coordinateToPrice(y1 + dy);
                                    const newTime2 = ts.coordinateToTime(x2 + dx);
                                    const newPrice2 = priceSeries.coordinateToPrice(y2 + dy);
                                    if (newTime1 && newPrice1 && newTime2 && newPrice2) {
                                        d.p1 = { time: newTime1, price: newPrice1 };
                                        d.p2 = { time: newTime2, price: newPrice2 };
                                        dragStartX = x;
                                        dragStartY = y;
                                    }
                                }
                            }
                            d.updateAllViews();
                            chart.timeScale().applyOptions({}); // Force redraw
                        }
                    } else if (d.type === 'percent-rect') {
                        // Drag handling for percent rectangle
                        const newPrice = priceSeries.coordinateToPrice(y);
                        const newTime = ts.coordinateToTime(x);
                        if (newPrice !== null && newTime !== null) {
                            if (dragTarget.handle === 'p1') {
                                // Move P1 corner
                                d.p1 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'p2') {
                                // Move P2 corner
                                d.p2 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'rect') {
                                // Move whole rectangle
                                const dx = x - dragStartX;
                                const dy = y - dragStartY;
                                const x1 = ts.timeToCoordinate(d.p1.time);
                                const y1 = priceSeries.priceToCoordinate(d.p1.price);
                                const x2 = ts.timeToCoordinate(d.p2.time);
                                const y2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                    const newTime1 = ts.coordinateToTime(x1 + dx);
                                    const newPrice1 = priceSeries.coordinateToPrice(y1 + dy);
                                    const newTime2 = ts.coordinateToTime(x2 + dx);
                                    const newPrice2 = priceSeries.coordinateToPrice(y2 + dy);
                                    if (newTime1 && newPrice1 && newTime2 && newPrice2) {
                                        d.p1 = { time: newTime1, price: newPrice1 };
                                        d.p2 = { time: newTime2, price: newPrice2 };
                                        dragStartX = x;
                                        dragStartY = y;
                                    }
                                }
                            }
                            // Recalculate percent difference after move
                            d.updatePercent();
                            d.updateAllViews();
                            chart.timeScale().applyOptions({}); // Force redraw
                        }
                    } else if (d.type === 'fibonacci') {
                        // Drag handling for fibonacci retracement
                        const newPrice = priceSeries.coordinateToPrice(y);
                        const newTime = ts.coordinateToTime(x);
                        if (newPrice !== null && newTime !== null) {
                            if (dragTarget.handle === 'p1') {
                                // Move P1 point
                                d.p1 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'p2') {
                                // Move P2 point
                                d.p2 = { time: newTime, price: newPrice };
                            } else if (dragTarget.handle === 'rect') {
                                // Move whole fibonacci
                                const dx = x - dragStartX;
                                const dy = y - dragStartY;
                                const x1 = ts.timeToCoordinate(d.p1.time);
                                const y1 = priceSeries.priceToCoordinate(d.p1.price);
                                const x2 = ts.timeToCoordinate(d.p2.time);
                                const y2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (x1 !== null && y1 !== null && x2 !== null && y2 !== null) {
                                    const newTime1 = ts.coordinateToTime(x1 + dx);
                                    const newPrice1 = priceSeries.coordinateToPrice(y1 + dy);
                                    const newTime2 = ts.coordinateToTime(x2 + dx);
                                    const newPrice2 = priceSeries.coordinateToPrice(y2 + dy);
                                    if (newTime1 && newPrice1 && newTime2 && newPrice2) {
                                        d.p1 = { time: newTime1, price: newPrice1 };
                                        d.p2 = { time: newTime2, price: newPrice2 };
                                        dragStartX = x;
                                        dragStartY = y;
                                    }
                                }
                            }
                            // Recalculate fibonacci levels after move
                            d.levels = d.calculateLevels();
                            d.updateAllViews();
                            chart.timeScale().applyOptions({}); // Force redraw
                        }
                    } else if (d.type === 'rect-range') {
                        const newPrice = priceSeries.coordinateToPrice(y);
                        if (newPrice !== null) {
                            if (dragTarget.handle === 'top') {
                                d.pHigh = Math.max(newPrice, d.pLow);
                            } else if (dragTarget.handle === 'bottom') {
                                d.pLow = Math.min(newPrice, d.pHigh);
                            } else if (dragTarget.handle === 'body') {
                                // move whole rect by deltaY
                                const dy = y - dragStartY;
                                const priceAtStart = priceSeries.coordinateToPrice(dragStartY);
                                const priceAtCurrent = priceSeries.coordinateToPrice(y);
                                if (priceAtStart !== null && priceAtCurrent !== null) {
                                    const pDelta = priceAtCurrent - priceAtStart;
                                    d.pLow += pDelta;
                                    d.pHigh += pDelta;
                                }
                                dragStartY = y;
                            }
                            d.updateAllViews();
                            chart.timeScale().applyOptions({});
                        }
                    }
                    e.preventDefault();
                    e.stopPropagation();
                }, true);

                container.addEventListener('mouseup', e => {
                    // End Y-panning
                    if (isYPanning) {
                        isYPanning = false;
                        yPanStartRange = null;
                        // Issue #4 Fix: Restore autoScale if streaming is active
                        // Issue #8 Fix: BUT NOT if user manually disabled it via panning
                        if (window._streamingAutoScale === true && window._userDisabledAutoScale !== true) {
                            rightScale.applyOptions({ autoScale: true });
                        }
                    }

                    if (isDragging && dragTarget) {
                        const d = dragTarget.drawing;
                        // Notify Python if a horizontal stop line was moved
                        if (d.type === 'hline' && d.id && pyBridge) {
                            console.log('Line drag ended:', d.id, 'new price:', d.price);
                            // Call Python bridge to notify about the move
                            pyBridge.onStopLineMoved(d.id, d.price);
                            // Update label with new price
                            d.label = d.label.replace(/@\s*[\d.]+/, '@ ' + d.price.toFixed(2));
                            d.updateAllViews();
                            chart.timeScale().applyOptions({}); // Force redraw
                        }
                        isDragging = false;
                        dragTarget = null;
                        container.style.cursor = currentTool === 'pointer' ? 'default' : 'crosshair';
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }, true);

                container.addEventListener('mouseleave', () => {
                    if (isDragging) {
                        isDragging = false;
                        dragTarget = null;
                    }
                    if (isYPanning) {
                        isYPanning = false;
                        yPanStartRange = null;
                        // Issue #4 Fix: Restore autoScale if streaming is active
                        // Issue #8 Fix: BUT NOT if user manually disabled it via panning
                        if (window._streamingAutoScale === true && window._userDisabledAutoScale !== true) {
                            rightScale.applyOptions({ autoScale: true });
                        }
                    }
                });

                // Issue #8: Double-click on chart to reset auto-scale
                // This allows user to restore automatic Y-scaling after manual panning
                container.addEventListener('dblclick', (e) => {
                    // Reset user's manual preference and restore auto-scaling
                    window._userDisabledAutoScale = false;
                    rightScale.applyOptions({ autoScale: true });
                    console.log('Double-click: Auto-scale restored');
                });

                // Helper: Get time from x-coordinate - works even in empty space
                // Uses coordinateToLogical which works outside data range
                function getTimeFromPixelX(pixelX) {
                    const ts = chart.timeScale();

                    try {
                        // Get the logical index at this x position (works outside data range!)
                        const logicalIndex = ts.coordinateToLogical(pixelX);
                if (logicalIndex === null) return null;

                // Get the data to find bar duration
                const data = priceSeries.data();
                if (!data || data.length < 2) {
                    // Fallback: try direct coordinateToTime
                    return ts.coordinateToTime(pixelX);
                }

                // Calculate bar duration from data
                const barDuration = Number(data[1].time) - Number(data[0].time);
                if (!isFinite(barDuration) || barDuration === 0) {
                    return ts.coordinateToTime(pixelX);
                }
                const firstBarTime = data[0].time;
                const firstBarLogical = 0; // First bar is at logical index 0

                        // Calculate time: firstTime + (logicalIndex - firstLogical) * barDuration
                        const calculatedTime = Math.round(firstBarTime + logicalIndex * barDuration);

                        return calculatedTime;
                    } catch (e) {
                        console.warn('getTimeFromPixelX failed:', e);
                        // Last resort fallback
                        return ts.coordinateToTime(pixelX);
                    }
                }

                // Click handler for drawing tools - using container event for full coverage
                container.addEventListener('click', e => {
                    if (isDragging) return; // Ignore clicks during drag
                    if (currentTool === 'pointer') return; // No drawing in pointer mode

                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const price = priceSeries.coordinateToPrice(y);
                    if (price === null) return;

                    // Get time using our robust function that works everywhere
                    let time = getTimeFromPixelX(x);
                    if (time === null) {
                        const data = priceSeries.data?.() || [];
                        time = data.length ? data[data.length - 1].time : null;
                    }

                    if (currentTool === 'hline-green') {
                        const lineId = genId();
                        const color = '#26a69a';
                        // Request label from Python (will call back to add the line)
                        if (pyBridge && pyBridge.onLineDrawRequest) {
                            pyBridge.onLineDrawRequest(lineId, price, color, 'green');
                        } else {
                            // Fallback: create line without label
                            const line = new HorizontalLinePrimitive(price, color, lineId);
                            priceSeries.attachPrimitive(line);
                            drawings.push(line);
                        }
                        selectTool('pointer');
                    }
                    else if (currentTool === 'hline-red') {
                        const lineId = genId();
                        const color = '#ef5350';
                        // Request label from Python (will call back to add the line)
                        if (pyBridge && pyBridge.onLineDrawRequest) {
                            pyBridge.onLineDrawRequest(lineId, price, color, 'red');
                        } else {
                            // Fallback: create line without label
                            const line = new HorizontalLinePrimitive(price, color, lineId);
                            priceSeries.attachPrimitive(line);
                            drawings.push(line);
                        }
                        selectTool('pointer');
                    }
                    else if (currentTool === 'trendline' || currentTool === 'ray') {
                        if (!time) return; // Need time for these tools
                        drawingPoints.push({ time, price });
                        if (drawingPoints.length === 2) {
                            removePreview();
                            const PrimitiveClass = currentTool === 'trendline' ? TrendLinePrimitive : RayPrimitive;
                            const color = currentTool === 'trendline' ? '#ffeb3b' : '#9c27b0';
                            const line = new PrimitiveClass(drawingPoints[0], drawingPoints[1], color, genId());
                            priceSeries.attachPrimitive(line);
                            drawings.push(line);
                            // Stay in drawing mode - reset points for next line (ESC to exit)
                            drawingPoints = [];
                        }
                    }
                    else if (currentTool === 'percent-rect') {
                        if (!time) return; // Need time for these tools
                        drawingPoints.push({ time, price });
                        if (drawingPoints.length === 2) {
                            removePreview();
                            const rect = new PercentRectPrimitive(drawingPoints[0], drawingPoints[1], genId());
                            priceSeries.attachPrimitive(rect);
                            drawings.push(rect);
                            selectTool('pointer');
                        }
                    }
                    else if (currentTool === 'rect-range') {
                        // Collect two price clicks; rectangle spans full width between those prices
                        rectStage = rectStage === null ? price : rectStage;
                        if (rectStage !== null && rectStage !== price) {
                            const low = Math.min(rectStage, price);
                            const high = Math.max(rectStage, price);
                            rectStage = null;
                            const label = prompt("Label für Zone (optional)", "") || "";
                            pickRectColor().then(color => {
                                const rect = new RectRangePrimitive(low, high, color, label, genId());
                                priceSeries.attachPrimitive(rect);
                                drawings.push(rect);
                                selectTool('pointer');
                            });
                        }
                    }
                    else if (currentTool === 'fibonacci') {
                        if (!time) return; // Need time for these tools
                        drawingPoints.push({ time, price });
                        if (drawingPoints.length === 2) {
                            removePreview();
                            const fib = new FibonacciRetracementPrimitive(drawingPoints[0], drawingPoints[1], genId());
                            priceSeries.attachPrimitive(fib);
                            drawings.push(fib);
                            // Stay in drawing mode - reset points for next fibonacci (ESC to exit)
                            drawingPoints = [];
                        }
                    }
                    else if (currentTool === 'zoom-rect') {
                        if (!time) return; // Need time for zoom selection
                        drawingPoints.push({ time, price });
                        if (drawingPoints.length === 2) {
                            removePreview();
                            const p1 = drawingPoints[0];
                            const p2 = drawingPoints[1];
                            // Calculate time range (convert to logical index)
                            const ts = chart.timeScale();
                            const logicalFrom = ts.timeToCoordinate(p1.time);
                            const logicalTo = ts.timeToCoordinate(p2.time);
                            // Find actual bar indices for time range
                            const allData = priceSeries.data();
                            let fromIdx = -1, toIdx = -1;
                            for (let i = 0; i < allData.length; i++) {
                                if (fromIdx < 0 && allData[i].time >= Math.min(p1.time, p2.time)) fromIdx = i;
                                if (allData[i].time <= Math.max(p1.time, p2.time)) toIdx = i;
                            }
                            if (fromIdx >= 0 && toIdx >= 0) {
                                // Add some padding (1 bar on each side)
                                fromIdx = Math.max(0, fromIdx - 1);
                                toIdx = Math.min(allData.length - 1, toIdx + 1);
                                // Set visible logical range
                                ts.setVisibleLogicalRange({ from: fromIdx, to: toIdx });
                                console.log('Zoomed to range: bars ' + fromIdx + ' to ' + toIdx);
                            }
                            drawingPoints = [];
                            selectTool('pointer');
                        }
                    }
                    else if (currentTool === 'delete') {
                        let nearest = null;
                        let nearestZoneId = null;
                        let minDist = 20;
                        drawings.forEach(d => {
                            if (d.type === 'hline') {
                                const lineY = priceSeries.priceToCoordinate(d.price);
                                if (lineY !== null) {
                                    const dist = Math.abs(y - lineY);
                                    if (dist < minDist) { minDist = dist; nearest = d; nearestZoneId = null; }
                                }
                            } else if (d.type === 'trendline' || d.type === 'ray') {
                                const ts = chart.timeScale();
                                const dx1 = ts.timeToCoordinate(d.p1.time);
                                const dy1 = priceSeries.priceToCoordinate(d.p1.price);
                                const dx2 = ts.timeToCoordinate(d.p2.time);
                                const dy2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (dx1 !== null && dy1 !== null && dx2 !== null && dy2 !== null) {
                                    const dist = pointToSegmentDist(x, y, dx1, dy1, dx2, dy2);
                                    if (dist < minDist) { minDist = dist; nearest = d; nearestZoneId = null; }
                                }
                            } else if (d.type === 'percent-rect') {
                                const ts = chart.timeScale();
                                const dx1 = ts.timeToCoordinate(d.p1.time);
                                const dy1 = priceSeries.priceToCoordinate(d.p1.price);
                                const dx2 = ts.timeToCoordinate(d.p2.time);
                                const dy2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (dx1 !== null && dy1 !== null && dx2 !== null && dy2 !== null) {
                                    const minX = Math.min(dx1, dx2), maxX = Math.max(dx1, dx2);
                                    const minY = Math.min(dy1, dy2), maxY = Math.max(dy1, dy2);
                                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                                        nearest = d; nearestZoneId = null; minDist = 0;
                                    }
                                }
                            } else if (d.type === 'fibonacci') {
                                // Fibonacci zones span full chart width, so only check Y bounds
                                const dy1 = priceSeries.priceToCoordinate(d.p1.price);
                                const dy2 = priceSeries.priceToCoordinate(d.p2.price);
                                if (dy1 !== null && dy2 !== null) {
                                    const minY = Math.min(dy1, dy2), maxY = Math.max(dy1, dy2);
                                    // Hit-detection across full chart width (consistent with rendering)
                                    if (y >= minY && y <= maxY) {
                                        nearest = d; nearestZoneId = null; minDist = 0;
                                    }
                                }
                            } else if (d.type === 'rect-range') {
                                const y1 = priceSeries.priceToCoordinate(d.pLow);
                                const y2 = priceSeries.priceToCoordinate(d.pHigh);
                                if (y1 !== null && y2 !== null) {
                                    const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                                    if (y >= minY && y <= maxY) {
                                        nearest = d; nearestZoneId = null; minDist = 0;
                                    }
                                }
                            }
                        });
                        // Also check zones (Python-managed zones stored separately)
                        Object.entries(zones).forEach(([zoneId, z]) => {
                            // Zone is a RectRangePrimitive with pLow/pHigh
                            const y1 = priceSeries.priceToCoordinate(z.pLow);
                            const y2 = priceSeries.priceToCoordinate(z.pHigh);
                            if (y1 !== null && y2 !== null) {
                                const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                                if (y >= minY && y <= maxY) {
                                    // Zone hit - prefer zones over drawings at same distance
                                    nearest = null;
                                    nearestZoneId = zoneId;
                                    minDist = 0;
                                }
                            }
                        });
                        if (nearestZoneId) {
                            // Remove zone via API
                            window.chartAPI.removeZone(nearestZoneId);
                            // Also notify Python bridge if available
                            if (pyBridge && pyBridge.onZoneDeleted) {
                                pyBridge.onZoneDeleted(nearestZoneId);
                            }
                        } else if (nearest) {
                            removeDrawing(nearest);
                        }
                    }
                });

                // Mouse move for preview - uses getTimeFromPixelX for snap-free positioning
                container.addEventListener('mousemove', e => {
                    if ((currentTool === 'trendline' || currentTool === 'ray') && drawingPoints.length === 1 && !isDragging) {
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const price = priceSeries.coordinateToPrice(y);
                        let time = getTimeFromPixelX(x);
                        if (time === null) {
                            const data = priceSeries.data?.() || [];
                            time = data.length ? data[data.length - 1].time : null;
                        }
                        if (price === null || time === null) return;
                        removePreview();
                        const PrimitiveClass = currentTool === 'trendline' ? TrendLinePrimitive : RayPrimitive;
                        const color = currentTool === 'trendline' ? 'rgba(255,235,59,0.5)' : 'rgba(156,39,176,0.5)';
                        previewPrimitive = new PrimitiveClass(drawingPoints[0], { time, price }, color, 'preview');
                        priceSeries.attachPrimitive(previewPrimitive);
                    }
                    else if (currentTool === 'percent-rect' && drawingPoints.length === 1 && !isDragging) {
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const price = priceSeries.coordinateToPrice(y);
                        let time = getTimeFromPixelX(x);
                        if (time === null) {
                            const data = priceSeries.data?.() || [];
                            time = data.length ? data[data.length - 1].time : null;
                        }
                        if (price === null || time === null) return;
                        removePreview();
                        previewPrimitive = new PercentRectPrimitive(drawingPoints[0], { time, price }, 'preview');
                        priceSeries.attachPrimitive(previewPrimitive);
                    }
                    else if (currentTool === 'fibonacci' && drawingPoints.length === 1 && !isDragging) {
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const price = priceSeries.coordinateToPrice(y);
                        let time = getTimeFromPixelX(x);
                        if (time === null) {
                            const data = priceSeries.data?.() || [];
                            time = data.length ? data[data.length - 1].time : null;
                        }
                        if (price === null || time === null) return;
                        removePreview();
                        previewPrimitive = new FibonacciRetracementPrimitive(drawingPoints[0], { time, price }, 'preview');
                        priceSeries.attachPrimitive(previewPrimitive);
                    }
                    else if (currentTool === 'zoom-rect' && drawingPoints.length === 1 && !isDragging) {
                        const rect = container.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const price = priceSeries.coordinateToPrice(y);
                        let time = getTimeFromPixelX(x);
                        if (time === null) {
                            const data = priceSeries.data?.() || [];
                            time = data.length ? data[data.length - 1].time : null;
                        }
                        if (price === null || time === null) return;
                        removePreview();
                        // Use PercentRect for preview (will show green/red based on direction)
                        previewPrimitive = new PercentRectPrimitive(drawingPoints[0], { time, price }, 'preview');
                        priceSeries.attachPrimitive(previewPrimitive);
                    }
                });

                // Ctrl+MouseWheel zoom: remember view + normalize panes
                container.addEventListener('wheel', e => {
                    if (e.ctrlKey) {
                        rememberViewState();
                        if (typeof e.deltaY === 'number') {
                            scalePaneLayout(e.deltaY < 0); // zoom in if deltaY negative
                        } else {
                            normalizePaneHeights();
                        }
                    }
                }, { passive: true });

                // Helper: distance from point to line segment
                function pointToSegmentDist(px, py, x1, y1, x2, y2) {
                    const dx = x2 - x1, dy = y2 - y1;
                    const lenSq = dx*dx + dy*dy;
                    if (lenSq === 0) return Math.sqrt((px-x1)*(px-x1) + (py-y1)*(py-y1));
                    let t = ((px-x1)*dx + (py-y1)*dy) / lenSq;
                    t = Math.max(0, Math.min(1, t));
                    const projX = x1 + t*dx, projY = y1 + t*dy;
                    return Math.sqrt((px-projX)*(px-projX) + (py-projY)*(py-projY));
                }

                // Toolbar button handlers
                document.getElementById('tool-pointer').onclick = () => selectTool('pointer');
                document.getElementById('tool-hline-green').onclick = () => selectTool('hline-green');
                document.getElementById('tool-hline-red').onclick = () => selectTool('hline-red');
                document.getElementById('tool-trendline').onclick = () => selectTool('trendline');
                document.getElementById('tool-ray').onclick = () => selectTool('ray');
                document.getElementById('tool-percent-rect').onclick = () => selectTool('percent-rect');
                document.getElementById('tool-rect-range').onclick = () => selectTool('rect-range');
                document.getElementById('tool-fibonacci').onclick = () => selectTool('fibonacci');
                document.getElementById('tool-zoom-rect').onclick = () => selectTool('zoom-rect');
                document.getElementById('tool-delete').onclick = () => selectTool('delete');
                document.getElementById('tool-clear-all').onclick = () => { clearAllDrawings(); selectTool('pointer'); };

                // Keyboard shortcuts
                document.addEventListener('keydown', e => {
                    if (e.key === 'Escape') { selectTool('pointer'); rectStage = null; }
                    if (e.key === 'Delete' && selectedDrawing) { removeDrawing(selectedDrawing); selectedDrawing = null; }
                });

                // Expose drawing API
                window.chartAPI.getDrawings = () => drawings.map(d => ({
                    id: d.id, type: d.type,
                    ...(d.type === 'hline'
                        ? { price: d.price, color: d.color, label: d.label, lineStyle: d.lineStyle }
                        : d.type === 'rect-range'
                            ? { priceLow: d.pLow, priceHigh: d.pHigh, color: d.color, label: d.label }
                            : d.type === 'percent-rect'
                                ? { p1: d.p1, p2: d.p2, color: d.color }
                                : d.type === 'fibonacci'
                                    ? { p1: d.p1, p2: d.p2 }
                                    : { p1: d.p1, p2: d.p2, color: d.color })
                }));
                window.chartAPI.clearDrawings = clearAllDrawings;

                // Zones handled separately to avoid clearing user drawings
                const zones = {};
                window.chartAPI.clearZones = () => {
                    Object.values(zones).forEach((z) => {
                        try { priceSeries.detachPrimitive(z); } catch(e) { console.error(e); }
                    });
                    Object.keys(zones).forEach(k => delete zones[k]);
                    console.log('Cleared zones');
                    return true;
                };
                window.chartAPI.addZone = (id, startTime, endTime, topPrice, bottomPrice, color, opacity, label = '') => {
                    try {
                        const zoneId = id || genId();
                        const fill = color || 'rgba(13,110,253,0.18)';
                        // Ensure correct ordering
                        const low = Math.min(topPrice, bottomPrice);
                        const high = Math.max(topPrice, bottomPrice);
                        // Remove existing with same id
                        if (zones[zoneId]) {
                            try { priceSeries.detachPrimitive(zones[zoneId]); } catch(e) {}
                        }
                        const rect = new RectRangePrimitive(low, high, fill, label || '', zoneId);
                        priceSeries.attachPrimitive(rect);
                        zones[zoneId] = rect;
                        console.log('addZone', zoneId, 'low=', low, 'high=', high, 'color=', fill);
                        return zoneId;
                    } catch(e){ console.error('addZone error:', e); return null; }
                };
                window.chartAPI.removeZone = (id) => {
                    try {
                        const zone = zones[id];
                        if (!zone) {
                            console.warn('removeZone: zone not found:', id);
                            return false;
                        }
                        priceSeries.detachPrimitive(zone);
                        delete zones[id];
                        console.log('removeZone:', id);
                        return true;
                    } catch(e) { console.error('removeZone error:', e); return false; }
                };
                window.chartAPI.getZoneIds = () => Object.keys(zones);
                window.chartAPI.hasZone = (id) => id in zones;
                window.chartAPI.addHorizontalLine = (price, color, label = '', lineStyle = 'solid', customId = null) => {
                    // Use custom ID if provided, otherwise generate one
                    const lineId = customId || genId();
                    // Remove existing line with same ID if updating
                    const existingIdx = drawings.findIndex(x => x.id === lineId);
                    if (existingIdx !== -1) {
                        const existing = drawings[existingIdx];
                        priceSeries.detachPrimitive(existing);
                        drawings.splice(existingIdx, 1);
                        console.log('Removed existing line with ID:', lineId);
                    }
                    const line = new HorizontalLinePrimitive(price, color || '#26a69a', lineId, label, lineStyle);
                    priceSeries.attachPrimitive(line);
                    drawings.push(line);
                    console.log('Added horizontal line at', price, 'with label:', label, 'ID:', lineId);
                    return line.id;
                };
                window.chartAPI.addTrendLine = (p1, p2, color) => {
                    const line = new TrendLinePrimitive(p1, p2, color || '#ffeb3b', genId());
                    priceSeries.attachPrimitive(line);
                    drawings.push(line);
                    return line.id;
                };
                window.chartAPI.addRectRange = (low, high, color, label = '') => {
                    const rect = new RectRangePrimitive(low, high, color || 'rgba(13,110,253,0.18)', label || '', genId());
                    priceSeries.attachPrimitive(rect);
                    drawings.push(rect);
                    console.log('addRectRange', low, high, color, label);
                    return rect.id;
                };
                window.chartAPI.addPercentRect = (p1, p2, customId = null) => {
                    const rect = new PercentRectPrimitive(p1, p2, customId || genId());
                    priceSeries.attachPrimitive(rect);
                    drawings.push(rect);
                    return rect.id;
                };
                window.chartAPI.addFibonacci = (p1, p2, customId = null) => {
                    const fib = new FibonacciRetracementPrimitive(p1, p2, customId || genId());
                    priceSeries.attachPrimitive(fib);
                    drawings.push(fib);
                    return fib.id;
                };
                window.chartAPI.removeDrawingById = (id) => {
                    const d = drawings.find(x => x.id === id);
                    if (d) removeDrawing(d);
                };

                // Clear all lines (hline type drawings)
                window.chartAPI.clearLines = () => {
                    try {
                        const linesToRemove = drawings.filter(d => d.type === 'hline');
                        linesToRemove.forEach(d => removeDrawing(d));
                        console.log('Cleared ' + linesToRemove.length + ' horizontal lines');
                        return true;
                    } catch(e) {
                        console.error('clearLines error:', e);
                        return false;
                    }
                };

                // Clear all drawings (all types)
                window.chartAPI.clearAllDrawings = () => {
                    try {
                        const toRemove = [...drawings];
                        toRemove.forEach(d => removeDrawing(d));
                        console.log('Cleared ' + toRemove.length + ' drawings');
                        return true;
                    } catch(e) {
                        console.error('clearAllDrawings error:', e);
                        return false;
                    }
                };

                // ==================== CHART COLORS UPDATE (Issues #34, #35, #37) ====================
                // Update chart colors dynamically without reloading HTML
                window.chartAPI.updateColors = (colors) => {
                    try {
                        // Update layout background color
                        if (colors.background) {
                            chart.applyOptions({
                                layout: {
                                    background: { type: 'solid', color: colors.background }
                                }
                            });
                        }

                        // Update candlestick colors
                        if (colors.upColor || colors.downColor || colors.wickUpColor || colors.wickDownColor) {
                            priceSeries.applyOptions({
                                upColor: colors.upColor || '#26a69a',
                                downColor: colors.downColor || '#ef5350',
                                wickUpColor: colors.wickUpColor || colors.upColor || '#26a69a',
                                wickDownColor: colors.wickDownColor || colors.downColor || '#ef5350'
                            });
                        }

                        console.log('Chart colors updated:', colors);
                        return true;
                    } catch(e) {
                        console.error('updateColors error:', e);
                        return false;
                    }
                };

                // Update background image dynamically without reloading HTML
                window.chartAPI.updateBackgroundImage = (imagePath, opacity) => {
                    try {
                        const container = document.getElementById('chart-container');
                        if (!container) {
                            console.error('chart-container not found');
                            return false;
                        }

                        // Remove existing style if present
                        let styleEl = document.getElementById('bg-image-style');
                        if (styleEl) {
                            styleEl.remove();
                        }

                        // If no image path, just remove the background
                        if (!imagePath) {
                            console.log('Background image removed');
                            return true;
                        }

                        // Create new style element
                        styleEl = document.createElement('style');
                        styleEl.id = 'bg-image-style';
                        const opacityValue = (opacity || 30) / 100.0;
                        styleEl.textContent = `
                            #chart-container::before {
                                content: '';
                                position: absolute;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background-image: url('${imagePath}');
                                background-size: cover;
                                background-position: center;
                                background-repeat: no-repeat;
                                opacity: ${opacityValue};
                                z-index: 0;
                                pointer-events: none;
                            }
                            #chart-container > * {
                                position: relative;
                                z-index: 1;
                            }
                        `;
                        document.head.appendChild(styleEl);

                        console.log('Background image updated:', imagePath, 'opacity:', opacityValue);
                        return true;
                    } catch(e) {
                        console.error('updateBackgroundImage error:', e);
                        return false;
                    }
                };

                // ==================== ROUNDED CANDLES OVERLAY (Issue #39) ====================
                // Based on TradingView official plugin pattern with performance optimizations:
                // - Native roundRect() for modern browsers (Chrome 99+, Firefox 112+, Safari 16+)
                // - Fallback using arcTo() for older browsers
                // - Pixel-aligned coordinates (Math.round) for performance
                // - Conditional rounding (only if candle width >= minWidth)
                // - Only draws visible candles (viewport-based rendering)
                // - Caching of candle dimensions for efficiency

                class RoundedCandlesOverlayPrimitive {
                    constructor(options = {}) {
                        this._options = {
                            radius: options.radius || 3,
                            // Issue #49: Reduced from 4 to 1 to show candles at max zoom out
                            minCandleBodyWidth: options.minCandleBodyWidth || 1,
                            enabled: options.enabled !== false,
                        };
                        this._paneViews = [new RoundedCandlesOverlayPaneView(this)];
                    }

                    updateAllViews() {
                        this._paneViews.forEach(v => v.update());
                    }

                    paneViews() {
                        return this._paneViews;
                    }

                    setBorderRadius(radius) {
                        this._options.radius = radius;
                        this._options.enabled = radius > 0;
                        this.updateAllViews();
                    }

                    setEnabled(enabled) {
                        this._options.enabled = enabled;
                        this.updateAllViews();
                    }
                }

                class RoundedCandlesOverlayPaneView {
                    constructor(source) {
                        this._source = source;
                    }

                    update() {
                        // Data comes from global roundedCandlesData
                    }

                    renderer() {
                        return new RoundedCandlesOverlayRenderer(
                            this._source._options
                        );
                    }
                }

                class RoundedCandlesOverlayRenderer {
                    constructor(options) {
                        this._options = options;
                    }

                    draw(target) {
                        // Only draw if enabled and border radius > 0
                        if (!this._options.enabled || this._options.radius === 0) {
                            return;
                        }

                        // Get data from global variable
                        const data = roundedCandlesData;
                        if (!data || data.length === 0) {
                            console.log('RoundedCandles: No data to draw');
                            return;
                        }

                        target.useBitmapCoordinateSpace(scope => {
                            const ctx = scope.context;
                            const pixelRatio = scope.verticalPixelRatio;
                            const horizontalPixelRatio = scope.horizontalPixelRatio;

                            console.log('RoundedCandles: Drawing', data.length, 'candles with radius', this._options.radius);

                            // Get time scale and convert data to screen coordinates
                            const timeScale = chart.timeScale();
                            const visibleLogicalRange = timeScale.getVisibleLogicalRange();
                            if (!visibleLogicalRange) return;

                            // Calculate candle width from bar spacing
                            const barSpacing = timeScale.options().barSpacing;
                            const candleWidth = Math.max(1, barSpacing * 0.8) * horizontalPixelRatio;

                            const radius = Math.min(this._options.radius * pixelRatio, candleWidth / 2);

                            // Get custom colors from window object (set by Python)
                            const bullishColor = window._customCandleColors?.upColor || '#26a69a';
                            const bearishColor = window._customCandleColors?.downColor || '#ef5350';

                            // Draw all candle bodies with rounded corners
                            data.forEach((bar, index) => {
                                // Get screen coordinates using proper TradingView API
                                const x = timeScale.timeToCoordinate(bar.time);
                                if (x === null) return; // Not visible

                                const yOpen = priceSeries.priceToCoordinate(bar.open);
                                const yClose = priceSeries.priceToCoordinate(bar.close);
                                if (yOpen === null || yClose === null) return;

                                // Convert to bitmap coordinates
                                const xBitmap = Math.round(x * horizontalPixelRatio);
                                const yOpenBitmap = Math.round(yOpen * pixelRatio);
                                const yCloseBitmap = Math.round(yClose * pixelRatio);

                                const bodyTop = Math.min(yOpenBitmap, yCloseBitmap);
                                const bodyBottom = Math.max(yOpenBitmap, yCloseBitmap);
                                const bodyHeight = bodyBottom - bodyTop;

                                // Skip if body height is too small (doji or very small body)
                                if (bodyHeight < 2 * pixelRatio) return;

                                // Skip rounding if candle is too narrow
                                if (candleWidth < this._options.minCandleBodyWidth * horizontalPixelRatio) return;

                                const halfWidth = candleWidth / 2;
                                const left = xBitmap - halfWidth;

                                // Set fill color based on candle direction
                                const isBullish = bar.close >= bar.open;
                                ctx.fillStyle = isBullish ? bullishColor : bearishColor;

                                // Calculate effective radius (don't exceed half of width or height)
                                const effectiveRadius = Math.min(radius, candleWidth / 2, bodyHeight / 2);

                                // Draw rounded rectangle
                                ctx.beginPath();

                                // Use native roundRect if available (Chrome 99+, Firefox 112+, Safari 16+)
                                if (typeof ctx.roundRect === 'function') {
                                    ctx.roundRect(left, bodyTop, candleWidth, bodyHeight, effectiveRadius);
                                } else {
                                    // Fallback for older browsers using arcTo
                                    const r = effectiveRadius;
                                    ctx.moveTo(left + r, bodyTop);
                                    ctx.arcTo(left + candleWidth, bodyTop, left + candleWidth, bodyTop + bodyHeight, r);
                                    ctx.arcTo(left + candleWidth, bodyTop + bodyHeight, left, bodyTop + bodyHeight, r);
                                    ctx.arcTo(left, bodyTop + bodyHeight, left, bodyTop, r);
                                    ctx.arcTo(left, bodyTop, left + candleWidth, bodyTop, r);
                                    ctx.closePath();
                                }

                                ctx.fill();

                                // Optional: Draw border for sharper definition
                                // (Commented out by default, can be enabled if desired)
                                // ctx.strokeStyle = isBullish ? bullishColor : bearishColor;
                                // ctx.lineWidth = 1;
                                // ctx.stroke();
                            });
                        });
                    }
                }

                // Store rounded candles overlay instance globally for dynamic updates
                let roundedCandlesOverlay = null;
                let roundedCandlesData = [];

                // Initialize rounded candle overlay (called after chart data is loaded)
                function initRoundedCandlesOverlay() {
                    if (!roundedCandlesOverlay) {
                        const borderRadius = parseInt(window._candleBorderRadius || 0);
                        if (borderRadius > 0) {
                            // Make standard candle bodies transparent so overlay is visible
                            const wickColor = window._customCandleColors?.upColor || '#26a69a';
                            priceSeries.applyOptions({
                                upColor: 'transparent',
                                downColor: 'transparent',
                                wickUpColor: wickColor,
                                wickDownColor: window._customCandleColors?.downColor || '#ef5350',
                                borderVisible: false
                            });

                            roundedCandlesOverlay = new RoundedCandlesOverlayPrimitive({
                                radius: borderRadius,
                                minCandleBodyWidth: 1,  // Issue #49: Allow narrow candles at zoom out
                                enabled: true
                            });
                            priceSeries.attachPrimitive(roundedCandlesOverlay);
                            console.log('Rounded candles overlay attached with radius:', borderRadius);
                        }
                    }
                }

                // Update border radius dynamically (exposed via chartAPI)
                window.chartAPI.updateCandleBorderRadius = (radius) => {
                    window._candleBorderRadius = radius;

                    if (radius === 0) {
                        // Remove overlay and restore standard candles
                        if (roundedCandlesOverlay) {
                            priceSeries.detachPrimitive(roundedCandlesOverlay);
                            roundedCandlesOverlay = null;
                        }

                        // Restore standard candle colors (from custom colors or defaults)
                        const upColor = window._customCandleColors?.upColor || '#26a69a';
                        const downColor = window._customCandleColors?.downColor || '#ef5350';
                        priceSeries.applyOptions({
                            upColor: upColor,
                            downColor: downColor,
                            wickUpColor: upColor,
                            wickDownColor: downColor,
                            borderVisible: false
                        });
                        console.log('Rounded candles overlay removed, standard candles restored');
                    } else {
                        // Make standard candles transparent if not already
                        const wickColor = window._customCandleColors?.upColor || '#26a69a';
                        priceSeries.applyOptions({
                            upColor: 'transparent',
                            downColor: 'transparent',
                            wickUpColor: wickColor,
                            wickDownColor: window._customCandleColors?.downColor || '#ef5350',
                            borderVisible: false
                        });

                        // Create or update overlay
                        if (!roundedCandlesOverlay) {
                            roundedCandlesOverlay = new RoundedCandlesOverlayPrimitive({
                                radius: radius,
                                minCandleBodyWidth: 1,  // Issue #49: Allow narrow candles at zoom out
                                enabled: true
                            });
                            priceSeries.attachPrimitive(roundedCandlesOverlay);
                            console.log('Rounded candles overlay created with radius:', radius);
                        } else {
                            roundedCandlesOverlay.setBorderRadius(radius);
                            console.log('Rounded candles overlay updated to radius:', radius);
                        }
                    }

                    // Request chart repaint
                    try {
                        chart.timeScale().scrollToPosition(0, false);
                    } catch(e) {
                        console.error('Failed to trigger chart repaint:', e);
                    }
                };

                // ==================== END DRAWING TOOLS ====================

                // ==================== CROSSHAIR TRACKING ====================
                // Subscribe to crosshair movements and notify Python bridge
                chart.subscribeCrosshairMove((param) => {
                    if (param.time && param.point && pyBridge) {
                        const price = priceSeries.coordinateToPrice(param.point.y);
                        if (price !== null) {
                            pyBridge.onCrosshairMove(param.time, price);
                        }
                    }
                });

                // Expose crosshair position getter
                window.chartAPI.getCrosshairPosition = () => {
                    // Returns the last known crosshair position from chart state
                    return window._lastCrosshairPosition || { time: null, price: null };
                };

                // Store crosshair position for local access
                chart.subscribeCrosshairMove((param) => {
                    if (param.time && param.point) {
                        const price = priceSeries.coordinateToPrice(param.point.y);
                        window._lastCrosshairPosition = {
                            time: param.time,
                            price: price
                        };
                    }
                });

                // ==================== ZONE CLICK HANDLING (Phase 5.7) ====================
                // Track zones for click detection
                window._zoneRegistry = window._zoneRegistry || {};

                // Register zone for click detection
                window.chartAPI.registerZoneForClick = (zoneId, top, bottom, label) => {
                    window._zoneRegistry[zoneId] = { top, bottom, label };
                    console.log('Zone registered for click:', zoneId);
                };

                // Unregister zone from click detection
                window.chartAPI.unregisterZoneFromClick = (zoneId) => {
                    delete window._zoneRegistry[zoneId];
                };

                // Find zone at price level
                window.chartAPI.findZoneAtPrice = (price) => {
                    for (const [zoneId, zone] of Object.entries(window._zoneRegistry)) {
                        if (price >= zone.bottom && price <= zone.top) {
                            return { id: zoneId, ...zone };
                        }
                    }
                    return null;
                };

                // Add click handler to chart container
                container.addEventListener('click', (e) => {
                    // Get price at click position
                    const rect = container.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    const price = priceSeries.coordinateToPrice(y);

                    if (price !== null && pyBridge) {
                        // Check if click is on a zone
                        const zone = window.chartAPI.findZoneAtPrice(price);
                        if (zone) {
                            console.log('Zone clicked:', zone.id, 'at price:', price);
                            pyBridge.onZoneClicked(zone.id, price, zone.top, zone.bottom, zone.label || '');
                        }
                    }
                });
                // ==================== END ZONE CLICK HANDLING ====================

                window.addEventListener('resize', () => {
                    if (window.chartAPI?.resizeToContainer) {
                        window.chartAPI.resizeToContainer();
                    }
                });

        document.getElementById('status').textContent = 'Ready v4 - waiting for data...';
            } catch (error) {
                console.error('CRITICAL INIT ERROR:', error);
                document.getElementById('status').textContent = 'ERROR: ' + error.message;
                document.getElementById('status').style.color = '#ff0000';
            }
        }

        setTimeout(initializeChart, 50);
    </script>
</body>
</html>
