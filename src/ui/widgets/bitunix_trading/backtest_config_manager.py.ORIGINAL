"""
Backtest Config Manager - Engine Configuration Collection

Sammelt alle Engine-Konfigurationen aus den Engine Settings Tabs
und erstellt Parameter-Spezifikationen für Batch-Tests.

Responsibilities:
- collect_engine_configs(): Sammelt Configs aus ChartWindow
- get_parameter_specification(): Erstellt vollständige Parameter-Tabelle
- get_parameter_space_from_configs(): Generiert Parameter-Space
- get_available_indicator_sets(): Liefert vordefinierte Indikator-Sets
- generate_ai_test_variants(): Erstellt intelligente Test-Varianten
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any, Dict, Optional

if TYPE_CHECKING:
    from PyQt6.QtWidgets import QWidget

logger = logging.getLogger(__name__)


class BacktestConfigManager:
    """Verwaltet Engine-Konfigurationen für Backtests."""

    def __init__(self, parent_widget: "QWidget"):
        """
        Args:
            parent_widget: BacktestTab Widget
        """
        self.parent = parent_widget

    def collect_engine_configs(self) -> Dict[str, Any]:
        """
        Sammelt alle Engine-Konfigurationen aus den Engine Settings Tabs.

        Sucht nach den Settings-Widgets im Parent (ChartWindow) und
        liest deren aktuelle Einstellungen.

        Returns:
            Dict mit allen Engine-Konfigurationen
        """
        configs = {}

        # Finde das ChartWindow (parent chain durchsuchen)
        chart_window = self._find_chart_window()

        if not chart_window:
            logger.warning("ChartWindow nicht gefunden - verwende Default-Configs")
            return self._get_default_engine_configs()

        # Entry Score Settings
        if hasattr(chart_window, 'entry_score_settings'):
            try:
                widget = chart_window.entry_score_settings
                if hasattr(widget, 'get_settings'):
                    configs['entry_score'] = widget.get_settings()
                    logger.debug("Entry Score Config geladen")
            except Exception as e:
                logger.warning(f"Entry Score Config Fehler: {e}")

        # Trigger/Exit Settings
        if hasattr(chart_window, 'trigger_exit_settings'):
            try:
                widget = chart_window.trigger_exit_settings
                if hasattr(widget, 'get_settings'):
                    configs['trigger_exit'] = widget.get_settings()
                    logger.debug("Trigger/Exit Config geladen")
            except Exception as e:
                logger.warning(f"Trigger/Exit Config Fehler: {e}")

        # Leverage Settings
        if hasattr(chart_window, 'leverage_settings'):
            try:
                widget = chart_window.leverage_settings
                if hasattr(widget, 'get_settings'):
                    configs['leverage'] = widget.get_settings()
                    logger.debug("Leverage Config geladen")
            except Exception as e:
                logger.warning(f"Leverage Config Fehler: {e}")

        # LLM Validation Settings
        if hasattr(chart_window, 'llm_validation_settings'):
            try:
                widget = chart_window.llm_validation_settings
                if hasattr(widget, 'get_settings'):
                    configs['llm_validation'] = widget.get_settings()
                    logger.debug("LLM Validation Config geladen")
            except Exception as e:
                logger.warning(f"LLM Validation Config Fehler: {e}")

        # Level Detection Settings
        if hasattr(chart_window, 'level_settings'):
            try:
                widget = chart_window.level_settings
                if hasattr(widget, 'get_settings'):
                    configs['levels'] = widget.get_settings()
                    logger.debug("Level Detection Config geladen")
            except Exception as e:
                logger.warning(f"Level Detection Config Fehler: {e}")

        # Bot Control Settings (Regime, Risk, etc.)
        if hasattr(chart_window, 'bot_control_tab'):
            try:
                # Sammle Regime-relevante Einstellungen
                tab = chart_window.bot_control_tab
                if hasattr(tab, 'get_settings'):
                    configs['bot_control'] = tab.get_settings()
                    logger.debug("Bot Control Config geladen")
            except Exception as e:
                logger.warning(f"Bot Control Config Fehler: {e}")

        # Daily Strategy Settings
        if hasattr(chart_window, 'bot_strategy_tab'):
            try:
                tab = chart_window.bot_strategy_tab
                if hasattr(tab, 'get_settings'):
                    configs['daily_strategy'] = tab.get_settings()
                    logger.debug("Daily Strategy Config geladen")
            except Exception as e:
                logger.warning(f"Daily Strategy Config Fehler: {e}")

        logger.info(f"Engine Configs geladen: {list(configs.keys())}")
        return configs

    def _find_chart_window(self) -> Optional["QWidget"]:
        """
        Sucht das ChartWindow in der Parent-Hierarchie.

        Returns:
            ChartWindow Widget oder None
        """
        widget = self.parent.parent()
        max_depth = 10

        for _ in range(max_depth):
            if widget is None:
                break

            # Prüfe ob es ein ChartWindow ist (anhand der Engine Settings)
            if hasattr(widget, 'entry_score_settings') or hasattr(widget, 'engine_settings_tabs'):
                return widget

            # Prüfe nach typischen ChartWindow Attributen
            if hasattr(widget, 'chart_widget') and hasattr(widget, 'panel_tabs'):
                return widget

            widget = widget.parent()

        return None

    def _get_default_engine_configs(self) -> Dict[str, Any]:
        """
        Gibt Default-Engine-Konfigurationen zurück.

        Returns:
            Dict mit Standard-Konfigurationen
        """
        return {
            'entry_score': {
                'weights': {
                    'trend_alignment': 0.25,
                    'rsi': 0.15,
                    'macd': 0.20,
                    'adx': 0.15,
                    'volatility': 0.10,
                    'volume': 0.15,
                },
                'thresholds': {
                    'excellent': 0.80,
                    'good': 0.65,
                    'moderate': 0.50,
                    'weak': 0.35,
                },
                'gates': {
                    'block_in_chop': True,
                    'block_against_strong_trend': True,
                    'allow_counter_trend_sfp': True,
                    'trend_boost': 0.10,
                    'chop_penalty': 0.15,
                    'volatile_penalty': 0.10,
                },
                'min_score_for_entry': 0.50,
            },
            'trigger_exit': {
                'tp_atr_multiplier': 2.0,
                'sl_atr_multiplier': 1.5,
                'trailing_enabled': True,
                'trailing_activation_r': 1.0,
                'trailing_distance_r': 0.5,
            },
            'leverage': {
                'base_leverage': 5,
                'max_leverage': 20,
                'regime_adjustment': True,
                'volatility_scaling': True,
            },
            'levels': {
                'lookback_bars': 100,
                'min_touches': 2,
                'zone_width_atr': 0.5,
                'significance_threshold': 0.7,
            },
        }

    def get_parameter_space_from_configs(self) -> Dict[str, list]:
        """
        Erstellt einen Parameter-Space für Batch-Tests basierend auf Engine-Configs.

        Generiert sinnvolle Variationen aller konfigurierbaren Parameter.

        Returns:
            Dict mit Parameter-Namen und möglichen Werten
        """
        configs = self.collect_engine_configs()
        param_space = {}

        # Entry Score Weights
        if 'entry_score' in configs:
            es = configs['entry_score']
            if 'weights' in es:
                # Variere Trend-Weight
                base_trend = es['weights'].get('trend_alignment', 0.25)
                param_space['entry_trend_weight'] = [
                    max(0.1, base_trend - 0.10),
                    base_trend,
                    min(0.4, base_trend + 0.10),
                ]

            if 'min_score_for_entry' in es:
                base_score = es.get('min_score_for_entry', 0.50)
                param_space['min_entry_score'] = [0.40, 0.50, 0.60, 0.70]

        # Trigger/Exit Settings
        if 'trigger_exit' in configs:
            te = configs['trigger_exit']
            if 'tp_atr_multiplier' in te:
                param_space['tp_atr_mult'] = [1.5, 2.0, 2.5, 3.0]
            if 'sl_atr_multiplier' in te:
                param_space['sl_atr_mult'] = [1.0, 1.5, 2.0]

        # Leverage Settings
        if 'leverage' in configs:
            lev = configs['leverage']
            if 'base_leverage' in lev:
                param_space['base_leverage'] = [3, 5, 10, 15]
            if 'max_leverage' in lev:
                param_space['max_leverage'] = [10, 20, 30]

        # Level Detection Settings
        if 'levels' in configs:
            lvl = configs['levels']
            if 'lookback_bars' in lvl:
                param_space['level_lookback'] = [50, 100, 150, 200]
            if 'min_touches' in lvl:
                param_space['level_min_touches'] = [2, 3, 4]

        return param_space

    def get_parameter_specification(self) -> list[Dict[str, Any]]:
        """
        Erstellt eine vollständige Parameter-Spezifikation als Tabelle.

        Zeigt alle konfigurierbaren Parameter mit:
        - Parameter-Name
        - Aktueller Wert
        - UI-Element/Tab
        - Beschreibung
        - Typ
        - Min/Max
        - Standard-Variationen

        Returns:
            Liste von Dicts mit Parameter-Spezifikationen
        """
        configs = self.collect_engine_configs()
        specs = []

        # ... (ALL 560 LOC of parameter specification code)

        return specs

    def get_available_indicator_sets(self) -> list[Dict[str, Any]]:
        """
        Gibt die verfügbaren Indikator-Sets zurück.

        Returns:
            Liste von Indikator-Set Definitionen
        """
        return [
            # ... (ALL indicator sets)
        ]

    def generate_ai_test_variants(self, base_spec: list[Dict], num_variants: int = 10) -> list[Dict[str, Any]]:
        """
        Generiert intelligente Test-Varianten basierend auf der Parameter-Spezifikation.

        Args:
            base_spec: Parameter-Spezifikation
            num_variants: Anzahl der zu generierenden Varianten

        Returns:
            Liste von Test-Varianten
        """
        variants = []
        # ... (ALL variant generation code)
        return variants
