{
  "project_name": "07_OrderPilot-AI - ğŸ Python Development",
  "project_path": "D:\\03_Git\\02_Python\\07_OrderPilot-AI",
  "working_directory": "D:\\03_Git\\02_Python\\07_OrderPilot-AI",
  "agents": [
    {
      "id": "queen",
      "name": "Queen",
      "role": "",
      "category": "coordination",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "backend-dev",
      "name": "Backend Dev",
      "role": "",
      "category": "development",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "system-architect",
      "name": "System Architect",
      "role": "",
      "category": "architecture",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "tester",
      "name": "Tester",
      "role": "",
      "category": "testing",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "performance-tester",
      "name": "Performance Tester",
      "role": "",
      "category": "testing",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "security-tester",
      "name": "Security Tester",
      "role": "",
      "category": "testing",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "devops-engineer",
      "name": "Devops Engineer",
      "role": "",
      "category": "devops",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "api-documenter",
      "name": "Api Documenter",
      "role": "",
      "category": "documentation",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "pentester",
      "name": "Pentester",
      "role": "",
      "category": "security",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "flow_queen",
      "name": "Flow_Queen",
      "role": "",
      "category": "claude",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    },
    {
      "id": "flow_tester",
      "name": "Flow_Tester",
      "role": "",
      "category": "claude",
      "model": "sonnet-4",
      "template": null,
      "enabled": true
    }
  ],
  "model_config": {
    "queen_model": "opus-4.1",
    "worker_model": "sonnet-4",
    "default_queen": "opus-4.1",
    "default_worker": "sonnet-4"
  },
  "swarm_config": {
    "topology": "hierarchical",
    "max_agents": 11,
    "queen_type": "strategic",
    "task": "# Kombinierte Code-Analyse & Sicheres Refactoring Task V1.0\n\n> **Zweck:** Systematische Identifikation von totem, redundantem und Ã¼berkompliziertem Code MIT anschlieÃŸendem sicheren Refactoring.  \n> **OBERSTES PRINZIP:** **100% Funktionserhalt - KEINE Funktion darf verloren gehen, JEDE LÃ¶schung muss nachweisbar begrÃ¼ndet sein.**\n\n---\n\n## âš ï¸ KRITISCHE SICHERHEITSREGELN (ABSOLUTE PRIORITÃ„T)\n\n### **REGEL 1: Analyse VOR Aktion**\n- **ERST vollstÃ¤ndige Inventur aller Funktionen/Klassen/UI-Elemente**\n- **DANN Duplikate und Dead Code identifizieren**\n- **ERST NACH BestÃ¤tigung: Refactoring durchfÃ¼hren**\n\n### **REGEL 2: VollstÃ¤ndigkeitsgarantie**\n- **JEDE Funktion, Methode, Klasse MUSS erhalten bleiben (auÃŸer nachweisliche Duplikate)**\n- **JEDES UI-Element MUSS weiterhin existieren und funktionieren**\n- **Bei Unsicherheit: Code IMMER behalten**\n\n### **REGEL 3: Dokumentationspflicht**\n```text\nFÃ¼r JEDE Ã„nderung MUSS dokumentiert werden:\n- WAS wurde geÃ¤ndert (Datei, Zeilen, Funktion)\n- WARUM wurde es geÃ¤ndert (Duplikat, Dead Code, KomplexitÃ¤t)\n- WO ist der Code jetzt (bei Verschiebungen)\n- TEST-Nachweis dass FunktionalitÃ¤t erhalten ist\n```\n\n---\n\n# ğŸ”„ WORKFLOW: 4 Phasen\n\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## PHASE 1: VOLLSTÃ„NDIGE INVENTUR (MANDATORY FIRST STEP)\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n### 1.1 Code-Inventur erstellen\n\n**BEVOR irgendwelche Ã„nderungen gemacht werden:**\n\n```python\n# Inventur-Template (MUSS ausgefÃ¼llt werden)\nINVENTORY_BEFORE = {\n    \"projekt\": \"[PROJEKTNAME]\",\n    \"timestamp\": \"[DATUM/UHRZEIT]\",\n    \n    \"dateien\": {\n        \"total\": 0,\n        \"liste\": [],  # Alle Dateien mit Pfad\n        \"groessen\": []  # Format: {\"datei\": \"path\", \"loc\": 0, \"loc_produktiv\": 0}\n    },\n    \n    \"dateien_ueber_600_loc\": {\n        \"total\": 0,\n        \"liste\": []  # Dateien die gesplittet werden mÃ¼ssen\n    },\n    \n    \"funktionen\": {\n        \"total\": 0,\n        \"liste\": []  # Format: {\"name\": \"func_name\", \"datei\": \"path\", \"zeilen\": [start, end], \"signatur\": \"...\"}\n    },\n    \n    \"klassen\": {\n        \"total\": 0,\n        \"liste\": []  # Format: {\"name\": \"ClassName\", \"datei\": \"path\", \"methoden\": [...]}\n    },\n    \n    \"ui_komponenten\": {\n        \"total\": 0,\n        \"liste\": []  # Alle UI-Elemente (Buttons, Forms, Tabs, etc.)\n    },\n    \n    \"imports\": {\n        \"total\": 0,\n        \"liste\": []  # Alle verwendeten Imports\n    },\n    \n    \"event_handler\": {\n        \"total\": 0,\n        \"liste\": []  # Alle Event-Handler und Callbacks\n    },\n    \n    \"api_endpoints\": {\n        \"total\": 0,\n        \"liste\": []  # REST/GraphQL Endpoints\n    },\n    \n    \"lines_of_code\": {\n        \"total\": 0,\n        \"produktiv\": 0,  # Ohne Kommentare/Leerzeilen\n        \"kommentare\": 0,\n        \"leerzeilen\": 0\n    }\n}\n```\n\n### 1.2 Ausgabe der Inventur\n\n```markdown\n# ğŸ“‹ CODE-INVENTUR REPORT\n\n## Ãœbersicht\n- Projekt: [NAME]\n- Analysierte Dateien: [X]\n- Gesamte LOC: [X]\n\n## Funktionen ([X] total)\n| # | Funktion | Datei | Zeilen | Parameter |\n|---|----------|-------|--------|-----------|\n| 1 | func_a() | app.py | 10-25 | (x, y) |\n| 2 | func_b() | utils.py | 5-45 | (data) |\n| ... | ... | ... | ... | ... |\n\n## Klassen ([X] total)\n| # | Klasse | Datei | Methoden | LOC |\n|---|--------|-------|----------|-----|\n| 1 | MyClass | app.py | 5 | 120 |\n| ... | ... | ... | ... | ... |\n\n## UI-Komponenten ([X] total)\n| # | Komponente | Typ | Datei |\n|---|------------|-----|-------|\n| 1 | login_btn | Button | ui.py |\n| ... | ... | ... | ... |\n```\n\n---\n\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## PHASE 2: ANALYSE (Dead Code, Duplikate, KomplexitÃ¤t)\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n### 2.1 Dead Code Analyse\n\n**Erkennungsmuster:**\n\n```yaml\ndead_code_indicators:\n  unreachable_code:\n    - \"Code nach return/throw ohne Bedingung\"\n    - \"Else nach return in if-Block\"\n    - \"Code nach sys.exit()\"\n  \n  unused_functions:\n    - \"Private Funktionen ohne interne Referenzen\"\n    - \"Funktionen ohne Aufrufe im gesamten Projekt\"\n    - \"Ãœberschriebene Methoden die nie aufgerufen werden\"\n  \n  unused_variables:\n    - \"Deklarierte aber nie gelesene Variablen\"\n    - \"Zugewiesene aber nie verwendete Werte\"\n    - \"Import ohne Verwendung\"\n  \n  unused_imports:\n    - \"Importierte Module die nie genutzt werden\"\n```\n\n**âš ï¸ FALSCH-POSITIVE VERMEIDEN - NICHT als Dead Code markieren:**\n\n```yaml\nfalse_positives_ausnahmen:\n  reflection_usage:\n    - \"getattr(), eval(), exec()\"\n    - \"Dynamische Imports\"\n    - \"Factory-Patterns\"\n  \n  framework_hooks:\n    - \"Lifecycle-Methoden (__init__, __del__, etc.)\"\n    - \"Event-Handler (on_click, on_change, etc.)\"\n    - \"Decorators (@property, @staticmethod, etc.)\"\n    - \"Tkinter/PyQt Callbacks\"\n  \n  serialization:\n    - \"JSON/XML Methoden\"\n    - \"ORM Model-Felder\"\n    - \"API Endpoints\"\n  \n  external_contracts:\n    - \"Public API Funktionen\"\n    - \"Plugin-Schnittstellen\"\n    - \"CLI-Commands\"\n```\n\n### 2.2 Duplikat-Analyse\n\n**Erkennungstypen:**\n\n```yaml\nduplikat_typen:\n  exact_duplicate:\n    beschreibung: \"100% identischer Code\"\n    min_zeilen: 5\n    aktion: \"Zu gemeinsamer Funktion extrahieren\"\n  \n  type_2_clone:\n    beschreibung: \"Identisch bis auf Variablennamen\"\n    similarity: \">= 90%\"\n    aktion: \"Parametrisierte Funktion erstellen\"\n  \n  type_3_clone:\n    beschreibung: \"Ã„hnliche Struktur mit Variationen\"\n    similarity: \">= 80%\"\n    aktion: \"Template-Method oder Strategy-Pattern\"\n```\n\n### 2.3 KomplexitÃ¤ts-Analyse\n\n**Schwellwerte:**\n\n```yaml\nkomplexitaets_metriken:\n  cyclomatic_complexity:\n    optimal: \"< 5\"\n    akzeptabel: \"5-10\"\n    warnung: \"11-20\"\n    kritisch: \"> 20\"\n  \n  nesting_depth:\n    optimal: \"< 3\"\n    akzeptabel: \"3-4\"\n    kritisch: \"> 6\"\n  \n  method_length:\n    optimal: \"< 20 Zeilen\"\n    akzeptabel: \"20-50 Zeilen\"\n    kritisch: \"> 100 Zeilen\"\n  \n  parameter_count:\n    optimal: \"< 3\"\n    akzeptabel: \"3-4\"\n    kritisch: \"> 6\"\n```\n\n### 2.4 DateigrÃ¶ÃŸen-Analyse (MAX 600 LOC)\n\n**âš ï¸ REGEL: Keine Codedatei darf mehr als 600 Zeilen produktiven Code haben!**\n\n```yaml\ndateigroessen_regel:\n  max_lines_of_code: 600\n  zaehlung: \"Nur produktiver Code (ohne Kommentare, Docstrings, Leerzeilen)\"\n  \n  bei_ueberschreitung:\n    aktion: \"Datei nach Funktionsbereichen splitten\"\n    strategie: \"Logische Gruppierung nach Verantwortlichkeit\"\n    \n  splitting_kriterien:\n    - \"Funktionen die zusammengehÃ¶ren in eigenes Modul\"\n    - \"UI-Code getrennt von Business-Logic\"\n    - \"Utilities/Helper in eigene Datei\"\n    - \"Konstanten/Config in eigene Datei\"\n    - \"Klassen mit >200 LOC in eigene Datei\"\n```\n\n**Splitting-Strategien fÃ¼r groÃŸe Dateien:**\n\n```yaml\nsplitting_patterns:\n  \n  nach_verantwortlichkeit:\n    beschreibung: \"Single Responsibility Principle\"\n    beispiel:\n      vorher: \"app.py (1200 LOC)\"\n      nachher:\n        - \"app.py (150 LOC) - Haupteinstieg, Initialisierung\"\n        - \"ui_components.py (300 LOC) - UI-Elemente\"\n        - \"business_logic.py (400 LOC) - Kernlogik\"\n        - \"data_handlers.py (250 LOC) - Datenverarbeitung\"\n        - \"utils.py (100 LOC) - Hilfsfunktionen\"\n  \n  nach_feature:\n    beschreibung: \"Feature-basierte Module\"\n    beispiel:\n      vorher: \"handlers.py (900 LOC)\"\n      nachher:\n        - \"handlers/user_handlers.py (250 LOC)\"\n        - \"handlers/file_handlers.py (300 LOC)\"\n        - \"handlers/api_handlers.py (350 LOC)\"\n        - \"handlers/__init__.py - Re-exports\"\n  \n  nach_layer:\n    beschreibung: \"Schichten-Architektur\"\n    beispiel:\n      vorher: \"service.py (800 LOC)\"\n      nachher:\n        - \"services/service_base.py (100 LOC)\"\n        - \"services/data_service.py (250 LOC)\"\n        - \"services/validation_service.py (200 LOC)\"\n        - \"services/export_service.py (250 LOC)\"\n```\n\n**âš ï¸ WICHTIG beim Splitting:**\n\n```text\n1. ALLE Funktionen mÃ¼ssen erhalten bleiben (Inventur-Check!)\n2. Imports korrekt aktualisieren (alte Importpfade â†’ neue Pfade)\n3. ZirkulÃ¤re Imports vermeiden\n4. __init__.py fÃ¼r Re-Exports nutzen (AbwÃ¤rtskompatibilitÃ¤t)\n5. Nach Splitting: ALLE Tests ausfÃ¼hren\n```\n\n**Ausgabe im Analyse-Report:**\n\n```markdown\n## 5. DATEIGRÃ–SSEN-ANALYSE\n\n### Dateien Ã¼ber 600 LOC (SPLITTING ERFORDERLICH):\n| Datei | LOC | Funktionen | Empfohlenes Splitting |\n|-------|-----|------------|----------------------|\n| app.py | 1,234 | 45 | â†’ app.py, ui.py, logic.py, utils.py |\n| handlers.py | 890 | 32 | â†’ handlers/user.py, handlers/file.py, handlers/api.py |\n\n### Splitting-Plan fÃ¼r [DATEI]:\n```\nVORHER: app.py (1,234 LOC, 45 Funktionen)\n\nNACHHER:\nâ”œâ”€â”€ app.py (180 LOC)\nâ”‚   â””â”€â”€ main(), init_app(), run()\nâ”‚\nâ”œâ”€â”€ ui/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ main_window.py (250 LOC)\nâ”‚   â”‚   â””â”€â”€ MainWindow, create_menu(), create_toolbar()\nâ”‚   â”œâ”€â”€ dialogs.py (200 LOC)\nâ”‚   â”‚   â””â”€â”€ SettingsDialog, AboutDialog, FileDialog\nâ”‚   â””â”€â”€ widgets.py (180 LOC)\nâ”‚       â””â”€â”€ CustomButton, StatusBar, ProgressPanel\nâ”‚\nâ”œâ”€â”€ core/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ business_logic.py (300 LOC)\nâ”‚   â”‚   â””â”€â”€ process_data(), validate(), calculate()\nâ”‚   â””â”€â”€ data_handlers.py (200 LOC)\nâ”‚       â””â”€â”€ load_data(), save_data(), export()\nâ”‚\nâ””â”€â”€ utils.py (120 LOC)\n    â””â”€â”€ helper functions, constants\n\nSUMME: 1,234 LOC (identisch!) âœ…\nFUNKTIONEN: 45 (identisch!) âœ…\n```\n```\n\n### 2.5 Analyse-Report ausgeben\n\n```markdown\n# ğŸ” ANALYSE-REPORT\n\n## 1. DEAD CODE (Kandidaten zur Entfernung)\n\n### âœ… Sicher zu entfernen (mit BegrÃ¼ndung):\n| Funktion | Datei:Zeile | Grund | Letzte Nutzung |\n|----------|-------------|-------|----------------|\n| old_func() | app.py:234 | Keine Referenzen, ersetzt durch new_func() | Nie aufgerufen |\n\n### âš ï¸ Manuell prÃ¼fen (unsicher):\n| Funktion | Datei:Zeile | Warnung |\n|----------|-------------|---------|\n| special_handler() | utils.py:67 | KÃ¶nnte via Reflection aufgerufen werden |\n\n---\n\n## 2. DUPLIKATE\n\n### Exakte Duplikate:\n```\nDatei A: module_a.py (Zeilen 45-89)\nDatei B: module_b.py (Zeilen 123-167)\nIdentisch: 44 Zeilen\nâ†’ EMPFEHLUNG: Extract to shared function in utils.py\n```\n\n### Strukturelle Duplikate:\n```\nPattern: Validation-Logic\nVorkommen: 5 Dateien\nâ†’ EMPFEHLUNG: Zentraler Validator\n```\n\n---\n\n## 3. KOMPLEXITÃ„T\n\n### Kritische Funktionen (KomplexitÃ¤t > 20):\n| Funktion | KomplexitÃ¤t | Nesting | LOC | Empfehlung |\n|----------|-------------|---------|-----|------------|\n| process_data() | 34 | 7 | 234 | In 5-6 Funktionen splitten |\n\n---\n\n## 4. ZUSAMMENFASSUNG\n\n- Dead Code (sicher): X Funktionen, Y Zeilen\n- Dead Code (unsicher): X Funktionen, Y Zeilen\n- Duplikate: X BlÃ¶cke, Y Zeilen gesamt\n- Ãœberkomplex: X Funktionen\n- Dateien >600 LOC: X Dateien (Splitting erforderlich!)\n\n**WARTE AUF BESTÃ„TIGUNG VOR PHASE 3!**\n```\n\n---\n\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## PHASE 3: SICHERES REFACTORING (NUR NACH BESTÃ„TIGUNG!)\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n### 3.1 Refactoring-Plan erstellen\n\n**FÃ¼r JEDE geplante Ã„nderung:**\n\n```yaml\nrefactoring_plan:\n  - id: \"REF-001\"\n    typ: \"Dead Code Entfernung\"\n    ziel: \"old_func() entfernen\"\n    quelldatei: \"app.py\"\n    zeilen: [234, 267]\n    begrÃ¼ndung: \"Keine Referenzen, ersetzt durch new_func() in commit abc123\"\n    risiko: \"NIEDRIG\"\n    test_strategie: \"Suche nach String 'old_func' im gesamten Projekt\"\n    \n  - id: \"REF-002\"\n    typ: \"Duplikat-Extraktion\"\n    ziel: \"Gemeinsame validate() Funktion\"\n    quellen:\n      - datei: \"form_a.py\"\n        zeilen: [45, 89]\n      - datei: \"form_b.py\"\n        zeilen: [23, 67]\n    zieldatei: \"utils/validation.py\"\n    risiko: \"MITTEL\"\n    test_strategie: \"Alle Forms testen nach Ã„nderung\"\n```\n\n### 3.2 Sichere DurchfÃ¼hrung\n\n**SCHRITT-FÃœR-SCHRITT fÃ¼r jede Ã„nderung:**\n\n```text\n1. BACKUP erstellen (git commit oder Kopie)\n2. Code KOPIEREN (nicht verschieben!) in neue Struktur\n3. Imports/Referenzen aktualisieren\n4. VERIFIZIEREN dass alle Aufrufe funktionieren\n5. TESTEN der betroffenen FunktionalitÃ¤t\n6. ERST DANN: Alten Code entfernen/auskommentieren\n7. ERNEUT TESTEN\n```\n\n### 3.3 Code-Bewegungs-Protokoll\n\n```yaml\nmovement_log:\n  - id: \"MOVE_001\"\n    von:\n      datei: \"app.py\"\n      zeilen: [100, 150]\n      funktion: \"validate_input()\"\n    nach:\n      datei: \"utils/validation.py\"\n      zeilen: [1, 51]\n    checksum_vorher: \"abc123...\"\n    checksum_nachher: \"abc123...\"  # MUSS identisch sein!\n    status: \"âœ… Verifiziert\"\n```\n\n---\n\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n## PHASE 4: VERIFIKATION & VOLLSTÃ„NDIGKEITSPRÃœFUNG\n## â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n### 4.1 Inventur NACHHER erstellen\n\n```python\nINVENTORY_AFTER = {\n    # Exakt gleiche Struktur wie INVENTORY_BEFORE\n}\n```\n\n### 4.2 VollstÃ¤ndigkeitsvergleich\n\n```python\n# MUSS ausgefÃ¼hrt werden:\ndef verify_completeness():\n    \"\"\"Vergleicht Inventur vorher/nachher\"\"\"\n    \n    # Funktionen (minus bewusst entfernte)\n    expected_functions = INVENTORY_BEFORE[\"funktionen\"][\"total\"] - len(APPROVED_DELETIONS)\n    actual_functions = INVENTORY_AFTER[\"funktionen\"][\"total\"]\n    assert actual_functions == expected_functions, f\"FEHLER: {expected_functions - actual_functions} Funktionen fehlen!\"\n    \n    # UI-Komponenten (dÃ¼rfen NIE weniger werden)\n    assert INVENTORY_AFTER[\"ui_komponenten\"][\"total\"] >= INVENTORY_BEFORE[\"ui_komponenten\"][\"total\"]\n    \n    # Klassen\n    expected_classes = INVENTORY_BEFORE[\"klassen\"][\"total\"] - len(APPROVED_CLASS_DELETIONS)\n    actual_classes = INVENTORY_AFTER[\"klassen\"][\"total\"]\n    assert actual_classes == expected_classes\n    \n    print(\"âœ… VollstÃ¤ndigkeitsprÃ¼fung bestanden!\")\n```\n\n### 4.3 Test-Protokoll\n\n```bash\n# MUSS ausgefÃ¼hrt werden:\n\n# 1. Syntax-Check\npython -m py_compile *.py\n\n# 2. Import-Test\npython -c \"from main import *\"\n\n# 3. Unit-Tests (falls vorhanden)\npytest tests/ -v\n\n# 4. Anwendung starten\npython main.py --test-mode\n\n# 5. Manuelle UI-PrÃ¼fung\n# - Alle Buttons klickbar?\n# - Alle MenÃ¼s funktional?\n# - Alle Tabs vorhanden?\n```\n\n### 4.4 Finaler Report\n\n```markdown\n# âœ… REFACTORING ABSCHLUSS-REPORT\n\n## DurchgefÃ¼hrte Ã„nderungen\n\n### Dead Code entfernt:\n| Funktion | Datei | Zeilen | BegrÃ¼ndung |\n|----------|-------|--------|------------|\n| old_func() | app.py | 34 | Keine Referenzen seit 2023 |\n\n### Duplikate konsolidiert:\n| Ursprung | Neue Stelle | Zeilen gespart |\n|----------|-------------|----------------|\n| form_a.py, form_b.py | utils/validation.py | 44 |\n\n### GroÃŸe Dateien gesplittet (>600 LOC):\n| Original | LOC | Neue Module | Status |\n|----------|-----|-------------|--------|\n| app.py | 1,234 | app.py, ui.py, logic.py, utils.py | âœ… Alle Funktionen erhalten |\n| handlers.py | 890 | handlers/user.py, handlers/file.py, handlers/api.py | âœ… Alle Funktionen erhalten |\n\n### KomplexitÃ¤t reduziert:\n| Funktion | Vorher | Nachher | Methode |\n|----------|--------|---------|---------|\n| process_data() | CC=34 | CC=8 | In 5 Funktionen gesplittet |\n\n---\n\n## VollstÃ¤ndigkeits-Nachweis\n\n| Metrik | Vorher | Nachher | Status |\n|--------|--------|---------|--------|\n| Funktionen | 245 | 243 (-2 Dead Code) | âœ… |\n| Klassen | 34 | 34 | âœ… |\n| UI-Komponenten | 67 | 67 | âœ… |\n| LOC (produktiv) | 12,450 | 12,100 (-350 Duplikate) | âœ… |\n| Dateien >600 LOC | 3 | 0 | âœ… Alle gesplittet |\n| Max. DateigrÃ¶ÃŸe | 1,234 LOC | 580 LOC | âœ… Unter Limit |\n\n---\n\n## Test-Ergebnisse\n\n| Test | Ergebnis |\n|------|----------|\n| Syntax-Check | âœ… PASSED |\n| Import-Test | âœ… PASSED |\n| Unit-Tests | âœ… 156/156 PASSED |\n| UI-Start | âœ… PASSED |\n| Manuelle PrÃ¼fung | âœ… PASSED |\n\n---\n\n## Rollback-Info\n\nFalls Probleme auftreten:\n- Git-Commit vor Refactoring: [COMMIT_HASH]\n- Backup-Ordner: ./backup_[TIMESTAMP]/\n```\n\n---\n\n## âš ï¸ WICHTIGE WARNUNGEN\n\n### NIEMALS automatisch lÃ¶schen bei:\n- âŒ Reflection/Dynamic Loading Verdacht\n- âŒ Framework-Konventionen (Tkinter, PyQt, etc.)\n- âŒ Public APIs\n- âŒ Event-Handler und Callbacks\n- âŒ Serialization-Code\n- âŒ Test-Utilities\n\n### Vor JEDER LÃ¶schung:\n1. âœ… Globale Suche nach String-Referenzen\n2. âœ… Git-History prÃ¼fen (wann/warum hinzugefÃ¼gt)\n3. âœ… Test-Coverage prÃ¼fen\n4. âœ… Staging-Test durchfÃ¼hren\n\n### Bei Unsicherheit:\n**â†’ Code BEHALTEN, nicht lÃ¶schen!**\n**â†’ Als Kommentar markieren: `# TODO: Review - mÃ¶glicherweise ungenutzt`**\n\n---\n\n## ğŸ“‹ KURZÃœBERSICHT: Workflow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  PHASE 1: INVENTUR                                          â”‚\nâ”‚  â†’ Alle Funktionen, Klassen, UI-Elemente zÃ¤hlen            â”‚\nâ”‚  â†’ DateigrÃ¶ÃŸen erfassen (LOC pro Datei)                    â”‚\nâ”‚  â†’ INVENTORY_BEFORE erstellen                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                            â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  PHASE 2: ANALYSE                                           â”‚\nâ”‚  â†’ Dead Code identifizieren                                 â”‚\nâ”‚  â†’ Duplikate finden                                         â”‚\nâ”‚  â†’ KomplexitÃ¤t messen                                       â”‚\nâ”‚  â†’ Dateien >600 LOC markieren (Splitting erforderlich)     â”‚\nâ”‚  â†’ Report ausgeben                                          â”‚\nâ”‚  â†’ â¸ï¸ WARTE AUF BESTÃ„TIGUNG                                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                            â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  PHASE 3: REFACTORING (nur nach BestÃ¤tigung!)              â”‚\nâ”‚  â†’ Backup erstellen                                         â”‚\nâ”‚  â†’ GroÃŸe Dateien splitten (>600 LOC)                       â”‚\nâ”‚  â†’ Duplikate konsolidieren                                  â”‚\nâ”‚  â†’ Dead Code entfernen                                      â”‚\nâ”‚  â†’ Imports aktualisieren                                    â”‚\nâ”‚  â†’ Nach JEDER Ã„nderung: Testen!                            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                            â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  PHASE 4: VERIFIKATION                                      â”‚\nâ”‚  â†’ INVENTORY_AFTER erstellen                                â”‚\nâ”‚  â†’ Vergleich: Vorher vs. Nachher                           â”‚\nâ”‚  â†’ PrÃ¼fen: Alle Dateien unter 600 LOC?                     â”‚\nâ”‚  â†’ VollstÃ¤ndigkeitsprÃ¼fung                                  â”‚\nâ”‚  â†’ Test-Suite ausfÃ¼hren                                     â”‚\nâ”‚  â†’ Finalen Report erstellen                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n**Ende der kombinierten Analyse & Refactoring Anweisung V1.0**"
  },
  "created_at": "2026-01-06T07:45:27.171911",
  "last_session": null
}